ACTION_IF !VARIABLE_IS_SET debug_variable BEGIN
   OUTER_SET debug_variable=0
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////               
/////////////              Define some symbols
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

OUTER_SPRINT ~percentage~ ~%~
OUTER_SPRINT ~atsymbol~ ~@~
OUTER_SPRINT ~tilde~ "~"
OUTER_SPRINT ~minus_one~ "-1"
OUTER_SPRINT ~arrow~ ~=>~

<<<<<<<< .../stratagems-inline/blank
>>>>>>>>

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               general warning message
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION patch_display_warning
         STR_VAR
             warning=""
             arguments=""
BEGIN
        PATCH_PRINT ~%warning%%arguments%~
        LPF patch_log_this STR_VAR file=SSL_warnings.txt input=EVALUATE_BUFFER ~%warning%%arguments%~ END
END

DEFINE_ACTION_FUNCTION action_display_warning
         STR_VAR
             warning=""
             arguments=""
BEGIN
        OUTER_INNER_PATCH ~~ BEGIN
           LPF patch_display_warning STR_VAR warning arguments END
        END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               compile SSL
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION ~compile_ssl_to_bcs_core~ INT_VAR skip_bcs=0 STR_VAR script="" variables="" location="" rename_to="" inline="" BEGIN
     LAF action_check_ini STR_VAR ini=disable_ssl RET disable_ssl=value END
     ACTION_IF ~%script%~ STRING_EQUAL_CASE ~~ BEGIN
        LAF action_display_warning STR_VAR warning="Warning: SSL compilation called with no script" END
     END
     ACTION_IF disable_ssl=0 BEGIN
          ACTION_IF !VARIABLE_IS_SET ~sslvariables~ BEGIN
             OUTER_SPRINT ~sslvariables~ ~~
          END
          ACTION_IF ~%variables%~ STRING_COMPARE_CASE ~~ BEGIN
             ACTION_IF ~%sslvariables%~ STRING_COMPARE_CASE ~~ BEGIN
               OUTER_SPRINT ~sslvariables~ ~%sslvariables%&%variables%~
             END ELSE BEGIN
               OUTER_SPRINT sslvariables ~%variables%~
             END
          END
          ACTION_IF ~%inline%~ STRING_EQUAL yes BEGIN
             COPY ~.../stratagems-inline/%script%.ssl~ ~%workspace%~
             OUTER_SPRINT full_loc ~%workspace%~
          END ELSE BEGIN

             ACTION_IF ~%sslvariables%~ STRING_COMPARE_CASE ~~ BEGIN
               OUTER_SPRINT ~sslvariables~ ~%sslvariables%&ssl_loc=%scsroot%\%location%~
             END ELSE BEGIN
               OUTER_SPRINT sslvariables ~%percentage%ssl_loc%percentage%=%scsroot%\%location%~
             END
             
             // sanity check
             ACTION_IF FILE_EXISTS ~%scsroot%\%location%\%script%.ssl~ BEGIN
                OUTER_SPRINT full_loc ~%scsroot%\%location%~
             END ELSE BEGIN
                ACTION_IF FILE_EXISTS ~%scsroot%\%component_loc%\%location%\%script%.ssl~ BEGIN
                   OUTER_SPRINT full_loc ~%scsroot%\%component_loc%\%location%~
                END ELSE BEGIN
                   FAIL ~SCS install error: the SSL file %script%.ssl cannot be found at %scsroot%\%location% or %scsroot%\%component_loc%\%location%~
                END
             END

          END
          ACTION_IF debug_variable=2 BEGIN
             LAF action_display_warning STR_VAR warning=EVALUATE_BUFFER ~SSL call with variables %sslvariables%~ END
          END
          ACTION_IF skip_tobex=0 BEGIN
             OUTER_SPRINT libwpn libwpn_tobex
          END ELSE BEGIN
             OUTER_SPRINT libwpn libwpn_notobex
          END



          ACTION_IF ~%WEIDU_OS%~ STRING_COMPARE_CASE ~WIN32~ THEN BEGIN
		AT_NOW ~chmod 755 %scsroot%/ssl/ssl.pl~
		AT_NOW ~/usr/bin/perl %scsroot%/ssl/ssl.pl "%full_loc%\%script% %sslvariables% -o %workspace%/ssl_out -l %scsroot%/ssl/library %scsroot%/ssl/%libwpn% %workspace%/autolib"~ EXACT
	  END ELSE BEGIN
		AT_NOW ~%scsroot%\ssl\ssl.exe "%full_loc%\%script% %sslvariables% -o %workspace%/ssl_out -l %scsroot%\ssl\library %scsroot%\ssl\%libwpn% %workspace%\autolib"~
	  END
	  ACTION_IF skip_bcs=0 BEGIN
	   ACTION_IF ~%rename_to%~ STRING_COMPARE_CASE ~~ BEGIN
	     COPY ~%workspace%\ssl_out\%script%.baf~ ~%workspace%\ssl_out\%rename_to%.baf~
             COMPILE EVALUATE_BUFFER ~%workspace%\ssl_out\%rename_to%.baf~
           END ELSE BEGIN
             COMPILE EVALUATE_BUFFER ~%workspace%\ssl_out\%script%.baf~
           END
          END
     END ELSE BEGIN
        LAF action_display_warning STR_VAR warning="Warning: SSL compilation disabled" END
     END
END

DEFINE_ACTION_FUNCTION ~ssl_to_bcs~
         STR_VAR script="" location=""  variables="" rename_to="" inline=""
BEGIN
         ACTION_IF ~%location%~ STRING_EQUAL_CASE ~~ BEGIN
            LAF action_get_directory RET location=directory END
         END
         ACTION_IF ~%script%~ STRING_EQUAL ~~ BEGIN
               LAF action_display_warning STR_VAR warning="Warning: SSL compiler called with empty argument" END
         END
         OUTER_WHILE ~%script%~ STRING_COMPARE ~~ BEGIN
               LAF action_return_first_entry STR_VAR list=EVALUATE_BUFFER ~%script%~ RET script=list script_to_call=entry END
               LAF compile_ssl_to_bcs_core STR_VAR script=EVALUATE_BUFFER ~%script_to_call%~ location variables rename_to inline END
         END

END

DEFINE_ACTION_FUNCTION ~ssl_to_baf~
         STR_VAR script="" location=""  variables="" inline=""
BEGIN
         ACTION_IF ~%location%~ STRING_EQUAL_CASE ~~ BEGIN
            LAF action_get_directory RET location=directory END
         END
         ACTION_IF ~%script%~ STRING_EQUAL ~~ BEGIN
               LAF action_display_warning STR_VAR warning="Warning: SSL compiler called with empty argument" END
         END
         OUTER_WHILE ~%script%~ STRING_COMPARE ~~ BEGIN
               LAF action_return_first_entry STR_VAR list=EVALUATE_BUFFER ~%script%~ RET script=list script_to_call=entry END
               LAF compile_ssl_to_bcs_core INT_VAR skip_bcs=1 STR_VAR script= EVALUATE_BUFFER ~%script_to_call%~ location variables inline  END
         END

END


DEFINE_ACTION_FUNCTION ~COMPILE_SSL_TO_BCS~         STR_VAR script="" location="" variables="" rename_to="" inline="" BEGIN   // legacy name
        LAF ssl_to_bcs STR_VAR script location variables rename_to inline END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               include a string as a line of code (NB: you can't define variables this way, because they're in the scope of the function)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_ACTION_FUNCTION action_reinclude_this
        STR_VAR
             input=""
BEGIN
       <<<<<<<< temp_file
       %input%
       >>>>>>>>
       ACTION_IF debug_variable=1 BEGIN
          PRINT ~%input%~
       END
       COPY + temp_file ~%workspace%/temp_file2~ EVALUATE_BUFFER
       REINCLUDE ~%workspace%/temp_file2~
END



DEFINE_PATCH_FUNCTION patch_reinclude_this
        STR_VAR
             input=""
BEGIN
       INNER_ACTION BEGIN
       <<<<<<<< temp_file
       %input%
       >>>>>>>>
          COPY + temp_file ~%workspace%/temp_file2~ EVALUATE_BUFFER
       END
       PATCH_IF debug_variable>0 BEGIN
          PATCH_PRINT ~%input%~
       END
       PATCH_REINCLUDE ~%workspace%/temp_file2~
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               break a comma-separated value string into its components
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_ACTION_FUNCTION decompose_CSV 
         STR_VAR
                input=""
         RET
                argument_0
                argument_1
                argument_2
                argument_3
                argument_4
                argument_5
                argument_6
                argument_7
                argument_8
                argument_9
BEGIN
     OUTER_SPRINT ~input~ EVALUATE_BUFFER ~%input%~
     OUTER_INNER_PATCH_SAVE ~output_csv~ ~ACTION_DEFINE_ARRAY temp_array BEGIN %input% END~ BEGIN
         REPLACE_TEXTUALLY ~,~ ~ ~
     END
       <<<<<<<< temp_file
       %output_csv%
       >>>>>>>>
       COPY + temp_file ~%workspace%/temp_file2~ EVALUATE_BUFFER
       REINCLUDE ~%workspace%/temp_file2~
     OUTER_FOR (i=0;i<10;i=i+1) BEGIN
        ACTION_IF (VARIABLE_IS_SET $temp_array(EVALUATE_BUFFER ~%i%~)) AND $temp_array(EVALUATE_BUFFER ~%i%~) STRING_COMPARE_CASE ~~ AND $temp_array(EVALUATE_BUFFER ~%i%~) STRING_COMPARE_CASE ~ ~ BEGIN
               OUTER_SPRINT EVALUATE_BUFFER ~argument_%i%~ $temp_array(~%i%~)
               OUTER_SPRINT ~temp~ $argument(~%i%~)
        END ELSE BEGIN
               OUTER_SPRINT EVALUATE_BUFFER ~argument_%i%~ ~null~
        END
     END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               as a patch, take ~key=>value~ and return key and value
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION process_arrow
           STR_VAR input=""
           RET     key
                   value
BEGIN
      PATCH_IF ~%input%~ STRING_COMPARE "" BEGIN
             SPRINT ~output~ ~ACTION_DEFINE_ASSOCIATIVE_ARRAY temp_assoc BEGIN %input% END~
          INNER_ACTION BEGIN
          <<<<<<<< temp_file
          %output%
          >>>>>>>>
             COPY + temp_file ~%workspace%/temp_file2~ EVALUATE_BUFFER
             REINCLUDE ~%workspace%/temp_file2~
          END
          PHP_EACH temp_assoc AS key => value BEGIN
          END
      END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               as a patch, take ~key value~ and return key and value
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION process_pair
           STR_VAR input=""
           RET     key
                   value
BEGIN
      PATCH_IF ~%input%~ STRING_COMPARE "" BEGIN
             SPRINT ~output~ ~ACTION_DEFINE_ARRAY temp_array BEGIN %input% END~
          INNER_ACTION BEGIN
          <<<<<<<< temp_file
          %output%
          >>>>>>>>
             COPY + temp_file ~%workspace%/temp_file2~ EVALUATE_BUFFER
             REINCLUDE ~%workspace%/temp_file2~
          END
          SPRINT ~key~ $temp_array(0)
          SPRINT ~value~ $temp_array(1)
      END

END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               as a patch, take a list of key=>value s separated by spaces, break it down, and for each entry INCLUDE a string (should usually be a function call) with <KEY> and <VALUE> set to their values
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION process_list_of_arrows
           STR_VAR filename=""
                   input=""
                   instruction=""
BEGIN
      PATCH_IF ~%input%~ STRING_COMPARE "" BEGIN
             SPRINT ~output~ ~ACTION_DEFINE_ASSOCIATIVE_ARRAY temp_assoc BEGIN %input% END~
          INNER_ACTION BEGIN
          <<<<<<<< temp_file
          %output%
          >>>>>>>>
             COPY + temp_file ~%workspace%/temp_file2~ EVALUATE_BUFFER
             REINCLUDE ~%workspace%/temp_file2~
          END
          PHP_EACH temp_assoc AS key => value BEGIN
                   INNER_PATCH_SAVE instruction2 ~%instruction%~ BEGIN
                      REPLACE_TEXTUALLY ~<key>~ ~%key%~
                      REPLACE_TEXTUALLY ~<value>~ ~%value%~
                   END
                   LAUNCH_PATCH_FUNCTION patch_reinclude_this STR_VAR input=~%instruction2%~ END

          END
      END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////            as a patch, process a list of space-separated integers and run a function on each
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION process_integer_list
     STR_VAR list=""
             function=""
BEGIN
     INNER_PATCH_SAVE ~list~ ~%list%~ BEGIN
        REPLACE_TEXTUALLY ~\(-[0-9]+\)~ ~"\1"~
     END
     SPRINT ~list~ ~PATCH_FOR_EACH entry IN %list% BEGIN LPF %function% INT_VAR arguments=EVALUATE_BUFFER "%entry%" END END~
     LPF patch_reinclude_this STR_VAR input=~%list%~ END



END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////            as a patch, process a list of space-separated strings and run a function on each, inputing it into the field "field"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION process_string_list
     STR_VAR list=""
             function=""
             field="arguments"
BEGIN
     SPRINT ~list~ ~PATCH_FOR_EACH entry IN %list% BEGIN LPF %function% STR_VAR %field%=EVALUATE_BUFFER "%percentage%entry%percentage%" END END~
     INNER_ACTION BEGIN
         <<<<<<<< temp_file
          %list%
          >>>>>>>>
             COPY + temp_file ~%workspace%/temp_file2~ EVALUATE_BUFFER
     END
     PATCH_REINCLUDE ~%workspace%/temp_file2~


END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////           take a string, strip any initial or trailing whitespace    [recursive]
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION strip_spaces_from_string
    STR_VAR string=""
    RET string
BEGIN
    PATCH_IF !(~%string%~ STRING_EQUAL ~~) BEGIN
       PATCH_IF INDEX (" " ~%string%~)=0 BEGIN
          INNER_PATCH_SAVE ~string~ ~%string%~ BEGIN DELETE_BYTES 0 1 END
          LPF strip_spaces_from_string STR_VAR string RET string=string END
       END
       PATCH_IF RINDEX (" " ~%string%~)=(STRING_LENGTH ~%string%~ -1) BEGIN
          INNER_PATCH_SAVE ~string~ ~%string%~ BEGIN DELETE_BYTES (BUFFER_LENGTH - 1) 1 END
          LPF strip_spaces_from_string STR_VAR string RET string=string END
       END
    END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////           take a string, strip initial or trailing ~ and "
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION strip_quotes_from_string
    STR_VAR string=""
    RET string
BEGIN
  SET string_length=STRING_LENGTH ~%string%~
  PATCH_MATCH string_length WITH 0 BEGIN
      LPF patch_display_warning STR_VAR warning="Warning: you just tried to remove quotes from an empty string. Deliberate?" END
  END
  DEFAULT
   INNER_PATCH_SAVE string ~%string%~ BEGIN
      SET lastloc=string_length - 1
      PATCH_FOR_EACH loc IN ~%lastloc%~ 0 BEGIN  // must be this way around!
         READ_ASCII 0 symbol (1)
         PATCH_IF (~%symbol%~ STRING_EQUAL ~"~ OR ~%symbol%~ STRING_EQUAL "~") BEGIN
             DELETE_BYTES loc 1
         END
      END
   END
  END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////            as a patch or action, take a list of variables, return the first entry, and strip it from the list
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION return_first_entry
     STR_VAR list=""
             separator=" "
     RET list
         entry
BEGIN
     // clean out any "\n"; process separator
     INNER_PATCH_SAVE list ~%list%~ BEGIN 
             REPLACE_TEXTUALLY ~%WNL%~ ~~
             REPLACE_TEXTUALLY ~%LNL%~ ~~
             REPLACE_TEXTUALLY ~%MNL%~ ~~
             REPLACE_TEXTUALLY ~%TAB%~ ~ ~
             PATCH_IF ~%separator%~ STRING_COMPARE ~ ~ BEGIN
                REPLACE_TEXTUALLY ~%separator%~ ~ ~
             END
     END
     LPF strip_spaces_from_string STR_VAR string= EVALUATE_BUFFER ~%list%~ RET list=string END
     INNER_PATCH ~%list%~ BEGIN READ_ASCII 0 first_char (1) END
     PATCH_IF (~%first_char%~ STRING_EQUAL ~"~ || ~%first_char%~ STRING_EQUAL "~") BEGIN
        SPRINT ~divider~ ~%first_char%~
        INNER_PATCH_SAVE ~list~ ~%list%~ BEGIN DELETE_BYTES 0 1 END // take off the " or ~
     END ELSE BEGIN
        SPRINT ~divider~ ~ ~
     END
     SET end_of_first= INDEX (~%divider%~ ~%list%~)
     PATCH_IF end_of_first <0 BEGIN // this should only happen if there are no " or ~
        SPRINT entry ~%list%~
        SPRINT list ~~
     END ELSE BEGIN
       INNER_PATCH_SAVE ~list~ ~%list%~ BEGIN
           READ_ASCII 0 entry (~end_of_first~)
           DELETE_BYTES 0 (end_of_first+1)
       END
     END
     LPF strip_spaces_from_string STR_VAR string=EVALUATE_BUFFER ~%list%~ RET list=string END
     LPF strip_quotes_from_string STR_VAR string=EVALUATE_BUFFER ~%entry%~ RET entry=string END
     LPF strip_spaces_from_string STR_VAR string=EVALUATE_BUFFER ~%entry%~ RET entry=string END



END

DEFINE_ACTION_FUNCTION action_return_first_entry
     STR_VAR list=""
     RET list
         entry
BEGIN
     OUTER_INNER_PATCH ~~ BEGIN
        LPF return_first_entry STR_VAR list RET list=list entry=entry END
     END
END

DEFINE_ACTION_FUNCTION return_first_entry
     STR_VAR list=""
     RET list
         entry
BEGIN
     OUTER_INNER_PATCH ~~ BEGIN
        LPF return_first_entry STR_VAR list RET list=list entry=entry END
     END
END




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////            as a patch or action, take a list of space-separated key => value pairs (or key->value pairs), return the first entries, and strip them from the list
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION return_first_pair
     STR_VAR list=""
     RET list
         key
         value

BEGIN
     INNER_PATCH_SAVE list ~%list%~ BEGIN REPLACE_TEXTUALLY ~=>~ ~ => ~ END
     // we can now treat the list as an ordinary list. Return the first entry, discard the second (which should be =>), return the third
     LPF return_first_entry STR_VAR list RET list=list key=entry END
     LPF return_first_entry STR_VAR list RET list=list discard=entry END
     PATCH_IF ~%discard%~ STRING_COMPARE_CASE ~=>~ BEGIN
        LPF patch_display_warning STR_VAR warning=EVALUATE_BUFFER "Warning: it looks as if some entry that should be a key=>value list, isn't (~list~ is currently %list%, key=%key%)" END
     END
     LPF return_first_entry STR_VAR list RET list=list value=entry END
END


DEFINE_ACTION_FUNCTION action_return_first_pair
     STR_VAR list=""
     RET key
         value
         list
BEGIN
     OUTER_INNER_PATCH ~~ BEGIN
        LPF return_first_pair STR_VAR list RET list=list key=key value=value END
     END
END

DEFINE_ACTION_FUNCTION return_first_pair
     STR_VAR list=""
     RET key
         value
         list
BEGIN
     OUTER_INNER_PATCH ~~ BEGIN
        LPF return_first_pair STR_VAR list RET list=list key=key value=value END
     END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////            as a patch, take as input a string and return its first letter and the rest of it
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION return_first_letter
       STR_VAR input=""
       RET firstletter
           rest
BEGIN
       PATCH_IF input STRING_COMPARE ~~ BEGIN
          INNER_PATCH_SAVE rest ~%input%~ BEGIN
             READ_ASCII 0x0 firstletter (1)
             DELETE_BYTES 0x0 1
          END
       END ELSE BEGIN
          SPRINT firstletter ~~
          SPRINT rest ~~
       END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////            as a patch, take as input FUNCTION(VALUES) and return FUNCTION and VALUES
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION return_function_and_argument
       STR_VAR input=""
       RET function
           argument
BEGIN
       INNER_PATCH_SAVE ~input~ ~%input%~ BEGIN
          REPLACE_TEXTUALLY ~)~ ~~
       END
       LPF return_first_entry
                STR_VAR list=EVALUATE_BUFFER ~%input%~ separator="("
                RET argument=list function=entry
       END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               define a set of simple data-field-editing functions from a table
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_ACTION_FUNCTION build_simple_data_field_editors
          STR_VAR lookup_table=""
                  function_prefix=""
                  offset_base=""
                  secondary="no"

BEGIN
       ACTION_PHP_EACH EVALUATE_BUFFER ~%lookup_table%~ AS function => arglist BEGIN
          LAUNCH_ACTION_FUNCTION decompose_CSV STR_VAR input=EVALUATE_BUFFER ~%arglist%~ RET offset=argument_0 type=argument_1 END
          ACTION_MATCH ~%offset_base%~
          WITH 
          ~~
          BEGIN
              OUTER_SPRINT ~offset~ ~%offset%~
          END
          DEFAULT
              OUTER_SPRINT ~offset~ ~(%offset% + %offset_base%)~
          END
          ACTION_MATCH ~%type%~
          WITH ~ASCII~
          BEGIN
                    OUTER_SPRINT ~definition~
                           ~DEFINE_PATCH_FUNCTION %function_prefix%_%function%  INT_VAR offset_base=0 STR_VAR arguments="" RET value BEGIN WRITE_ASCIIE %offset% "%percentage%arguments%percentage%" (8) SET value=1 END
                            DEFINE_PATCH_FUNCTION %function_prefix%_read_%function% INT_VAR offset_base=0 RET value BEGIN READ_ASCII %offset% value END~
          END
          ~ASCII20~
          BEGIN
                    OUTER_SPRINT ~definition~
                           ~DEFINE_PATCH_FUNCTION %function_prefix%_%function% INT_VAR offset_base=0 STR_VAR arguments="" RET value BEGIN WRITE_ASCIIE %offset% "%percentage%arguments%percentage%" (0x20) SET value=1 END
                            DEFINE_PATCH_FUNCTION %function_prefix%_read_%function% STR_VAR offset_base=0 RET value BEGIN READ_ASCII %offset% value (0x20) NULL   END~
          END
          ~ASCII2~
          BEGIN
                    OUTER_SPRINT ~definition~
                           ~DEFINE_PATCH_FUNCTION %function_prefix%_%function% INT_VAR offset_base=0 STR_VAR arguments="" RET value BEGIN WRITE_ASCIIE %offset% "%percentage%arguments%percentage%" (0x2) SET value=1 END
                            DEFINE_PATCH_FUNCTION %function_prefix%_read_%function% STR_VAR offset_base=0 RET value BEGIN READ_ASCII %offset% value (0x2) NULL   END~
          END
          DEFAULT
                    OUTER_SPRINT ~definition~ ~
                          DEFINE_PATCH_FUNCTION %function_prefix%_%function% INT_VAR offset_base=0 STR_VAR arguments="" RET value BEGIN WRITE_%type% %offset% arguments SET value=1 END
                          DEFINE_PATCH_FUNCTION %function_prefix%_%function%GT INT_VAR offset_base=0 STR_VAR arguments="" RET value BEGIN PATCH_IF %type%_AT %offset% < arguments BEGIN WRITE_%type% %offset% arguments END SET value=1 END
                          DEFINE_PATCH_FUNCTION %function_prefix%_%function%LT INT_VAR offset_base=0 STR_VAR arguments="" RET value BEGIN PATCH_IF %type%_AT %offset% > arguments BEGIN WRITE_%type% %offset% arguments END SET value=1 END
                          DEFINE_PATCH_FUNCTION %function_prefix%_read_%function% INT_VAR offset_base=0 RET value BEGIN READ_%type% %offset% value END~
          END
          ACTION_IF ~%secondary%~ STRING_EQUAL_CASE ~yes~ BEGIN
              OUTER_PATCH_SAVE ~definition~ ~%definition%~ BEGIN
                 REPLACE_TEXTUALLY ~offset_base~ ~offset_secondary~
              END
          END
          LAUNCH_ACTION_FUNCTION action_reinclude_this STR_VAR input=EVALUATE_BUFFER ~%definition%~ END
       END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               define a set of simple data-field-editing functions using IDS lookup from a table
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_ACTION_FUNCTION build_IDS_data_field_editors
          STR_VAR lookup_table=""
                  function_prefix=""
                  offset_base=""
                  secondary="no"

BEGIN
       ACTION_PHP_EACH EVALUATE_BUFFER ~%lookup_table%~ AS function => arglist BEGIN
          LAF decompose_CSV STR_VAR input=EVALUATE_BUFFER ~%arglist%~ RET offset=argument_0 type=argument_1 idsfile=argument_2 END
          ACTION_MATCH ~%offset_base%~
          WITH
          ~~
          BEGIN
              OUTER_SPRINT ~offset~ ~%offset%~
          END
          DEFAULT
              OUTER_SPRINT ~offset~ ~(%offset% + %offset_base%)~
          END
          ACTION_IF ~%type%~ STRING_EQUAL_CASE ~LONG_REVERSED~ THEN BEGIN
             OUTER_SPRINT definition ~
                        DEFINE_PATCH_FUNCTION %function_prefix%_%function% INT_VAR offset_base=0 STR_VAR arguments="" RET value BEGIN
                          SET ids_value = IDS_OF_SYMBOL (%idsfile% "%arguments%")
                          PATCH_IF ids_value>0 BEGIN
                               LPF reverse_long INT_VAR input=ids_value RET ids_value=output END
                               WRITE_LONG %offset% ids_value
                          END ELSE BEGIN
                               LPF patch_display_warning STR_VAR warning=EVALUATE_BUFFER "tried to set nonexistent %idsfile% entry %arguments%" END
                          END
                          SET value=1
                        END


                        DEFINE_PATCH_FUNCTION %function_prefix%_read_%function% INT_VAR offset_base=0 RET value BEGIN
                          READ_LONG %offset% value_ids
                          LPF reverse_long INT_VAR input=value_ids RET value_ids=output END
                          LOOKUP_IDS_SYMBOL_OF_INT value %idsfile% value_ids
                        END
              ~
          END ELSE BEGIN
             OUTER_SPRINT ~definition~ ~
                        DEFINE_PATCH_FUNCTION %function_prefix%_%function% INT_VAR offset_base=0 STR_VAR arguments="" RET value BEGIN
                          SET ids_value = IDS_OF_SYMBOL (%idsfile% "%arguments%")
                          PATCH_IF ids_value>0 BEGIN
                               WRITE_%type% %offset% ids_value
                          END ELSE BEGIN
                               LPF patch_display_warning STR_VAR warning=EVALUATE_BUFFER "tried to set nonexistent %idsfile% entry %arguments%" END
                          END
                          SET value=1
                        END

                        DEFINE_PATCH_FUNCTION %function_prefix%_read_%function% INT_VAR offset_base=0 RET value BEGIN
                          READ_%type% %offset% value_ids
                          LOOKUP_IDS_SYMBOL_OF_INT value %idsfile% value_ids
                        END
                       ~
          END
          ACTION_IF ~%secondary%~ STRING_EQUAL_CASE ~yes~ BEGIN
              OUTER_PATCH_SAVE ~definition~ ~%definition%~ BEGIN
                 REPLACE_TEXTUALLY ~offset_base~ ~offset_secondary~
              END
          END
          LAF action_reinclude_this STR_VAR input=EVALUATE_BUFFER ~%definition%~ END
       END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               define a set of simple data-field-editing functions using flags
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_ACTION_FUNCTION build_flag_data_field_editors
          STR_VAR lookup_table=""
                  function_prefix=""
                  offset_base=""
                  secondary=""

BEGIN
       ACTION_PHP_EACH EVALUATE_BUFFER ~%lookup_table%~ AS function => arglist BEGIN
          LAF decompose_CSV STR_VAR input=EVALUATE_BUFFER ~%arglist%~ RET offset=argument_0 bit=argument_1 END
          ACTION_MATCH ~%offset_base%~
          WITH
          ~~
          BEGIN
              OUTER_SPRINT ~offset~ ~%offset%~
          END
          DEFAULT
              OUTER_SPRINT ~offset~ ~(%offset% + %offset_base%)~
          END
          // input is in NI conventions counting 0-7, so bit N is 2^N
          OUTER_SET one_code=2**bit
          OUTER_SET zero_code=0xff - one_code
          OUTER_SPRINT ~definition~ ~
                       DEFINE_PATCH_FUNCTION %function_prefix%_%function% INT_VAR offset_base=0 STR_VAR arguments="" RET value BEGIN
                                     PATCH_IF arguments=0 BEGIN
                                        WRITE_BYTE %offset% (BYTE_AT %offset% BAND %zero_code%)
                                     END ELSE BEGIN
                                        WRITE_BYTE %offset% (BYTE_AT %offset% BOR %one_code%)
                                     END
                                     SET value=1

                       END
                       DEFINE_PATCH_FUNCTION %function_prefix%_read_%function% INT_VAR offset_base=0 RET value BEGIN
                                     PATCH_IF (BYTE_AT %offset% BAND %one_code%)  = 0 BEGIN
                                        SET value=0
                                     END ELSE BEGIN
                                        SET value=1
                                     END
                       END
                       ~
          ACTION_IF ~%secondary%~ STRING_EQUAL_CASE ~yes~ BEGIN
              OUTER_PATCH_SAVE ~definition~ ~%definition%~ BEGIN
                 REPLACE_TEXTUALLY ~offset_base~ ~offset_secondary~
              END
          END
          LAF action_reinclude_this STR_VAR input=EVALUATE_BUFFER ~%definition%~ END
       END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               template for general clone
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION clone_template
    STR_VAR
           file_list=""
           file_prefix=""
           edits=""
           editstring=""
           allow_missing="no"
BEGIN
      PRINT ~SFO: Cloning %file_prefix% file(s) %file_list% and applying patch(es)...~
      SILENT
      OUTER_WHILE !(~%file_list%~ STRING_EQUAL ~~) BEGIN
           LAF action_return_first_pair
                 STR_VAR list=EVALUATE_BUFFER ~%file_list%~
                 RET filename_old=key
                     filename_new=value
                     file_list=list
           END
           
           ACTION_IF ~%allow_missing%~ STRING_EQUAL_CASE yes BEGIN
              ACTION_IF FILE_EXISTS_IN_GAME ~%filename_old%.%file_prefix%~ BEGIN 
                      OUTER_SET proceed=1
              END ELSE BEGIN
                      OUTER_SET proceed=0
              END
           END ELSE BEGIN
              OUTER_SET proceed=1
           END
           ACTION_IF proceed=1 BEGIN
           COPY_EXISTING ~%filename_old%.%file_prefix%~ ~override/%filename_new%.%file_prefix%~
                 PATCH_IF debug_variable=2 BEGIN 
                    LPF patch_display_warning STR_VAR warning=EVALUATE_BUFFER ~Patching %SOURCE_RES%~ END
                    PATCH_SILENT
                 END
                    LPF apply_patches
                           INT_VAR really_no_default=1
                           STR_VAR edits
                                   editstring
                                   filename=EVALUATE_BUFFER ~%filename_old%~
                                   file_prefix
                    END
           // BUT_ONLY // no BUT_ONLY here - we want a clone regardless
           END
      END
      VERBOSE
      PRINT ~...done~
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               template for general edit
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////




DEFINE_ACTION_FUNCTION edit_template
    STR_VAR
           file_list=""
           file_prefix=""
           edits=""
           editstring=""
           allow_missing="no"
           external_file=""
           tv="no"
BEGIN
      ACTION_IF ~%external_file%~ STRING_COMPARE_CASE ~~ BEGIN
         LAF read_in_list STR_VAR file=EVALUATE_BUFFER ~%scsroot%/%component_loc%/%external_file%~ RET extra=list END
         OUTER_SPRINT ~file_list~ ~%file_list% %extra%~
      END
      ACTION_IF (~%edits%~ STRING_EQUAL_CASE ~~ && ~%editstring%~ STRING_EQUAL_CASE ~~) BEGIN
         OUTER_SPRINT edits patch_data
      END
      PRINT ~SFO: Applying patch(es) to %file_prefix% file(s) %file_list%... ~
      SILENT
      OUTER_WHILE !(~%file_list%~ STRING_EQUAL ~~) BEGIN
          LAF action_return_first_entry
                 STR_VAR list=EVALUATE_BUFFER ~%file_list%~
                 RET file_list=list filename=entry
          END
          ACTION_IF ~%tv%~ STRING_EQUAL_CASE "yes" BEGIN
             OUTER_SPRINT ~filename~ ~%tutu_var%%filename%~
          END
          ACTION_IF ~%allow_missing%~ STRING_EQUAL_CASE "yes" BEGIN
           ACTION_IF FILE_EXISTS_IN_GAME ~%filename%.%file_prefix%~ BEGIN
            COPY_EXISTING ~%filename%.%file_prefix%~ ~override/%filename%.%file_prefix%~
              PATCH_IF (SOURCE_SIZE>0x1) BEGIN
                    LPF apply_patches
                           STR_VAR edits=EVALUATE_BUFFER ~%edits%~
                                   editstring=EVALUATE_BUFFER ~%editstring%~
                                   filename=EVALUATE_BUFFER ~%filename%~
                                   file_prefix=EVALUATE_BUFFER ~%file_prefix%~
                    END
              END
            BUT_ONLY

           END
          END ELSE BEGIN
            COPY_EXISTING ~%filename%.%file_prefix%~ ~override/%filename%.%file_prefix%~
              PATCH_IF (SOURCE_SIZE>0x1) BEGIN
                    LPF apply_patches
                           STR_VAR edits=EVALUATE_BUFFER ~%edits%~
                                   editstring=EVALUATE_BUFFER ~%editstring%~
                                   filename=EVALUATE_BUFFER ~%filename%~
                                   file_prefix=EVALUATE_BUFFER ~%file_prefix%~
                    END
              END
            BUT_ONLY
          END
      END
      VERBOSE
      PRINT ~...done~
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               template for general regexp
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION regexp_template
    STR_VAR
           file_prefix=""
           edits=""
           editstring=""
           glob="yes"
           tv="no"
BEGIN
     ACTION_IF ~%tv%~ STRING_EQUAL_CASE "yes" BEGIN
          OUTER_SPRINT ~initial~ ~%tutu_var%~
          ACTION_IF VARIABLE_IS_SET EVALUATE_BUFFER ~file_count_%file_prefix%_tv~ BEGIN
              OUTER_SET count= EVALUATE_BUFFER ~file_count_%file_prefix%_tv~
          END ELSE BEGIN
              OUTER_SET count=0
          END
      END ELSE BEGIN
          OUTER_SPRINT ~initial~ ~~
          ACTION_IF VARIABLE_IS_SET EVALUATE_BUFFER ~file_count_%file_prefix%~ BEGIN
              OUTER_SET count= EVALUATE_BUFFER ~file_count_%file_prefix%~
          END ELSE BEGIN
              OUTER_SET count=0
          END
      END
      PRINT ~SFO: Applying patch(es) to all %file_prefix% files...~
      SILENT
      ACTION_IF ~%glob%~ STRING_EQUAL_CASE ~yes~ BEGIN
        OUTER_SET counter=0
        OUTER_SET report=0
        COPY_EXISTING_REGEXP GLOB ~%initial%.*\.%file_prefix%~ ~override~
           PATCH_IF (SOURCE_SIZE>0x1) THEN BEGIN
                    SPRINT filename ~%SOURCE_RES%~
                    PATCH_IF debug_variable=2 BEGIN
                       LPF patch_display_warning STR_VAR warning=EVALUATE_BUFFER ~Trying to patch %filename%...~ END
                       PATCH_SILENT
                    END
                    LPF apply_patches
                           STR_VAR edits=EVALUATE_BUFFER ~%edits%~
                                   editstring=EVALUATE_BUFFER ~%editstring%~
                                   filename=EVALUATE_BUFFER ~%filename%~
                                   file_prefix=EVALUATE_BUFFER ~%file_prefix%~
                    END
           END
           SET counter=counter+1
           PATCH_IF counter=100 BEGIN
              SET counter=0
              SET report=report+100
              PATCH_IF count>0 BEGIN
                 PATCH_PRINT ~Patched %report% / %count% files~
              END ELSE BEGIN
                 PATCH_PRINT ~Patched %report% files~
              END
              PATCH_SILENT
           END
        BUT_ONLY

      END ELSE BEGIN

COPY_EXISTING_REGEXP ~%initial%.*\.%file_prefix%~ ~override~
           PATCH_IF (SOURCE_SIZE>0x1) THEN BEGIN
                    SPRINT filename ~%SOURCE_RES%~
                    PATCH_IF debug_variable=2 BEGIN
                       LPF patch_display_warning STR_VAR warning=EVALUATE_BUFFER ~Trying to patch %filename%...~ END
                       PATCH_SILENT
                    END
                    LPF apply_patches
                           STR_VAR edits=EVALUATE_BUFFER ~%edits%~
                                   editstring=EVALUATE_BUFFER ~%editstring%~
                                   filename=EVALUATE_BUFFER ~%filename%~
                                   file_prefix=EVALUATE_BUFFER ~%file_prefix%~
                    END
           END
        BUT_ONLY


      END
      VERBOSE
      PRINT ~...done~
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               template for general new thing
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION make_template
    STR_VAR
           file_list=""
           file_prefix=""
           edits=""
           editstring=""
           build_before=""
           build_after=""
BEGIN
      PRINT ~SFO: Creating %file_prefix% file(s) %file_list%...~
      SILENT
      OUTER_WHILE !(~%file_list%~ STRING_EQUAL ~~) BEGIN
          LAF action_return_first_entry 
                 STR_VAR list=EVALUATE_BUFFER ~%file_list%~
                 RET file_list=list filename=entry
          END
          <<<<<<<< blank
          >>>>>>>>
          COPY ~blank~ ~override/%filename%.%file_prefix%~
                    LPF ~%build_before%~ END
                    LPF apply_patches
                           INT_VAR really_no_default=1
                           STR_VAR edits=EVALUATE_BUFFER ~%edits%~
                                   editstring=EVALUATE_BUFFER ~%editstring%~ 
                                   filename=EVALUATE_BUFFER ~%filename%~
                                   file_prefix=EVALUATE_BUFFER ~%file_prefix%~
                    END
                    PATCH_IF ~%build_after%~ STRING_COMPARE_CASE ~~ BEGIN
                       LPF ~%build_after%~  END
                    END
          BUT_ONLY //
      END
      VERBOSE
      PRINT ~...done~
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               wrapper to handle the FP_func nomenclature
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION apply_standard_function
    INT_VAR offset_secondary=0
    STR_VAR offset_base=""
            func=""
            arguments=""
            filename=""
            file_prefix=""
BEGIN
   TO_UPPER file_prefix
   PATCH_TRY
       PATCH_SILENT
       LPF ~%file_prefix%_%func%~ INT_VAR offset_secondary STR_VAR offset_base arguments filename file_prefix END
       PATCH_VERBOSE
   WITH
       ~Failure("Unknown function: %file_prefix%_%func%")~
       BEGIN
          LPF ~%func%~ INT_VAR offset_secondary STR_VAR offset_base arguments filename file_prefix END
       END
       DEFAULT
          LPF patch_display_warning STR_VAR warning=EVALUATE_BUFFER ~Unknown failure %ERROR_MESSAGE% in apply_standard_function: inputs were func=%func%, arguments=%arguments%~ END
          PATCH_RERAISE
       END
END




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               general templates to apply patches from a list
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION apply_patches
     INT_VAR
             offset_secondary=0
             really_no_default=0
     STR_VAR
             edits=""
             editstring=""
             arguments=""
             file_prefix=""
             filename=""
             offset_base="0"
             is_conditional="no"
BEGIN

          PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
             SPRINT ~edits~ ~%arguments%~
          END
          PATCH_IF (~%edits%%editstring%~ STRING_EQUAL_CASE ~~ && really_no_default=0) BEGIN
               SPRINT edits patch_data
          END
          PHP_EACH EVALUATE_BUFFER ~%edits%~ AS function => args BEGIN
              PATCH_IF debug_variable=2 BEGIN
                 PATCH_PRINT ~input to apply_patches: %function% %args%~
              END
              INNER_PATCH_SAVE ~function2~ ~%function%~ BEGIN
                 REPLACE_TEXTUALLY ~'~ ~~ // handle duplicates
              END
              PATCH_IF debug_variable=2 BEGIN PATCH_PRINT ~Running function %function2%~ END
              PATCH_MATCH ~%function2%~ WITH
              checkGT checkLT check match match_parameter effect_patch // these aren't function calls    [but see "ARE_check", "SPL_check" hacks]
              BEGIN
                   PATCH_IF ~%is_conditional%~ STRING_EQUAL_CASE ~no~ BEGIN
                      LPF patch_display_warning STR_VAR warning="warning: trying to use a conditional command in an unconditional patch" END
                   END
              END
              type
              BEGIN END
              literal
              BEGIN
                   LPF patch_reinclude_this STR_VAR input=EVALUATE_BUFFER ~%args%~ END
              END
              DEFAULT
                    // this bit can't be a PATCH_MATCH as I unwisely allowed check etc to be used as variable names
                    PATCH_IF !(~%function2%~ STRING_EQUAL_CASE check || ~%function2%~ STRING_EQUAL_CASE checkGT ||~%function2%~ STRING_EQUAL_CASE checkLT ||~%function2%~ STRING_EQUAL_CASE type) BEGIN
                      PATCH_IF debug_variable=2 BEGIN
                        PATCH_PRINT ~Calling %function2%, arguments %offset_secondary% %args% %filename% %offset_base% %file_prefix%~
                      END
                      LPF apply_standard_function INT_VAR offset_secondary STR_VAR func=EVALUATE_BUFFER ~%function2%~ arguments=EVALUATE_BUFFER ~%args%~ filename offset_base file_prefix END
                    END
              END
          END
          WHILE !(~%editstring%~ STRING_EQUAL ~~) BEGIN
             LPF return_first_pair STR_VAR list=EVALUATE_BUFFER ~%editstring%~ RET editstring=list function=key argument=value END
             INNER_PATCH_SAVE ~function~ ~%function%~ BEGIN REPLACE_TEXTUALLY ~'~ ~~ END // ' isn't necessary in an inline patch, but we might forget
             PATCH_MATCH ~%function%~ WITH
                check checkGT checkLT match match_parameter type effect_patch
             BEGIN END
               literal
             BEGIN
                   LPF patch_reinclude_this STR_VAR input=EVALUATE_BUFFER ~%argument%~ END
             END
             DEFAULT
              // this bit can't be a PATCH_MATCH as I unwisely allowed check etc to be used as variable names
              PATCH_IF !(~%function%~ STRING_EQUAL_CASE check || ~%function%~ STRING_EQUAL_CASE checkGT ||~%function%~ STRING_EQUAL_CASE checkLT ||~%function%~ STRING_EQUAL_CASE type) BEGIN
                 PATCH_IF debug_variable=2 BEGIN
                    PATCH_PRINT ~Calling %function%, arguments %offset_secondary% %argument% %filename% %offset_base% %file_prefix%~
                 END
                 LPF apply_standard_function INT_VAR offset_secondary STR_VAR arguments=EVALUATE_BUFFER ~%argument%~ filename file_prefix offset_base func=EVALUATE_BUFFER ~%function%~ END
              END
             END
          END

END

/////////////               wrapper to handle the FP_func nomenclature

DEFINE_PATCH_FUNCTION check_standard_function
    INT_VAR offset_secondary=0
    STR_VAR offset_base=""
            func=""
            arguments=""
            parameter=""
            filename=""
            file_prefix=""
    RET value
BEGIN
   TO_UPPER file_prefix
   PATCH_TRY
       PATCH_SILENT
       LPF ~%file_prefix%_read_%func%~ INT_VAR offset_secondary STR_VAR offset_base arguments parameter filename file_prefix RET value=value END
       PATCH_VERBOSE
   WITH
       ~Failure("Unknown function: %file_prefix%_read_%func%")~
       BEGIN
          PATCH_TRY
             PATCH_SILENT
             LPF ~%file_prefix%_%func%~ INT_VAR offset_secondary STR_VAR offset_base arguments parameter filename file_prefix RET value=value END
             PATCH_VERBOSE
          WITH
                 ~Failure("Unknown function: %file_prefix%_%func%")~
                 BEGIN
                      LPF ~%func%~ INT_VAR offset_secondary STR_VAR offset_base arguments filename file_prefix parameter RET value=value END
                 END 
                 DEFAULT
                      LPF patch_display_warning STR_VAR warning=EVALUATE_BUFFER ~Unknown failure %ERROR_MESSAGE% in check_standard_function: inputs were func=%func%, arguments=%arguments%~ END
                      PATCH_RERAISE
                 END
       END
       DEFAULT
          LPF patch_display_warning STR_VAR warning=EVALUATE_BUFFER ~Unknown failure %ERROR_MESSAGE% in check_standard_function: inputs were func=%func%, arguments=%arguments%~ END
          PATCH_RERAISE
       END
END


DEFINE_PATCH_FUNCTION apply_conditional_patches
     INT_VAR
             offset_secondary=0
     STR_VAR
             edits=""
             editstring=""
             arguments=""
             file_prefix=""
             filename=""
             offset_base="0"
          RET value
BEGIN
          SET value=1
          PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
             SPRINT ~edits~ ~%arguments%~
          END
          SPRINT match returns_true
          SPRINT check true
          SPRINT match_parameter ""
          SET checktype=1
          PHP_EACH ~%edits%~ AS func=>arg BEGIN
              PATCH_MATCH ~%func%~ WITH
                 match BEGIN
                    SPRINT match ~%arg%~
                 END
                 check BEGIN
                    SPRINT check ~%arg%~
                 END
                 checkGT BEGIN
                    SPRINT checkGT ~%arg%~
                    SET checktype=2
                 END
                 checkLT BEGIN
                    SPRINT checkLT ~%arg%~
                    SET checktype=3
                 END
                 match_parameter BEGIN
                    SPRINT match_parameter ~%arg%~
                 END
                 DEFAULT END
          END
          LPF check_standard_function INT_VAR offset_secondary STR_VAR offset_base filename file_prefix func=EVALUATE_BUFFER ~%match%~ parameter=EVALUATE_BUFFER ~%match_parameter%~ arguments=EVALUATE_BUFFER ~%match_parameter%~ RET value=value END
          PATCH_IF debug_variable>0 BEGIN
             PATCH_PRINT ~fn=%match% offset_base=%offset_base% offset_secondary=%offset_secondary% value=%value%~
          END
          SET found_match=0
          PATCH_MATCH checktype WITH
          1 BEGIN
             PATCH_IF ~%value%~ STRING_EQUAL_CASE ~%check%~ BEGIN
                SET found_match=1
             END
          END
          2 BEGIN
             PATCH_IF ~value~ >= ~checkGT~ BEGIN
                SET found_match=1
             END
          END
          3 BEGIN
             PATCH_IF ~value~ <= ~checkLT~ BEGIN
                SET found_match=1
             END
          END
          DEFAULT
             LPF patch_display_warning STR_VAR warning="Warning: no check value in conditional patch" END
          END

          PATCH_IF found_match=1 BEGIN
             LAUNCH_PATCH_FUNCTION apply_patches
                INT_VAR
                     offset_secondary=offset_secondary
                STR_VAR
                     edits=EVALUATE_BUFFER ~%edits%~
                     editstring=EVALUATE_BUFFER ~%editstring%~
                     file_prefix=EVALUATE_BUFFER ~%file_prefix%~
                     filename=EVALUATE_BUFFER ~%filename%~
                     offset_base=EVALUATE_BUFFER ~%offset_base%~
                     is_conditional="yes"
             END
          END
END


DEFINE_PATCH_FUNCTION patch_conditionally
       STR_VAR
                arguments=""
                file_prefix=""
                filename=""
       RET value
BEGIN
         SET value=1
         SET type_set=0
         PHP_EACH ~%arguments%~ AS func=>arg BEGIN
              PATCH_IF ~%func%~ STRING_EQUAL_CASE type BEGIN
                 SPRINT type ~%arg%~
                 SET type_set=1
              END
         END
         PATCH_IF !type_set BEGIN
            PATCH_PRINT ~Warning: type has not been set~
         END
         PATCH_IF (~%type%~ STRING_EQUAL_CASE ~effect~ && ~%file_prefix%~ STRING_COMPARE_CASE cre) BEGIN
           LAUNCH_PATCH_FUNCTION walk_effect_tree
            INT_VAR ab_length= ~%file_prefix%~ STRING_EQUAL_CASE ~itm~? 0x38 :0x28
            STR_VAR function=apply_conditional_patches
                    arguments=EVALUATE_BUFFER ~%arguments%~
                    file_prefix=EVALUATE_BUFFER ~%file_prefix%~
                    filename=EVALUATE_BUFFER ~%filename%~
                    entry_type=EVALUATE_BUFFER ~%type%~

           END
         END ELSE
         PATCH_IF ~%type%~ STRING_EQUAL_CASE ~transition~ BEGIN
           LAUNCH_PATCH_FUNCTION walk_transition_tree
            STR_VAR function=apply_conditional_patches
                    arguments=EVALUATE_BUFFER ~%arguments%~
                    file_prefix=EVALUATE_BUFFER ~%file_prefix%~
                    filename=EVALUATE_BUFFER ~%filename%~
                    entry_type=EVALUATE_BUFFER ~%type%~
           END
         END ELSE
         PATCH_IF ~%type%~ STRING_EQUAL_CASE ~none~ BEGIN
           LPF ~apply_conditional_patches~
            STR_VAR arguments=EVALUATE_BUFFER ~%arguments%~
                    file_prefix=EVALUATE_BUFFER ~%file_prefix%~
                    filename=EVALUATE_BUFFER ~%filename%~
           END
         END ELSE
         PATCH_IF ~%type%~ STRING_EQUAL_CASE ~type~ BEGIN
           LAUNCH_PATCH_FUNCTION patch_display_warning STR_VAR warning=EVALUATE_BUFFER "Trying to patch_conditionally on %filename%, but no type has been specified" END
         END ELSE BEGIN
           LAUNCH_PATCH_FUNCTION walk_entries
            STR_VAR function=apply_conditional_patches
                    arguments=EVALUATE_BUFFER ~%arguments%~
                    file_prefix=EVALUATE_BUFFER ~%file_prefix%~
                    filename=EVALUATE_BUFFER ~%filename%~
                    entry_type=EVALUATE_BUFFER ~%type%~
           END
         END

END

DEFINE_PATCH_FUNCTION patch_cond_inline
        STR_VAR
               arguments=""
               file_prefix=""
               filename=""
BEGIN
        SPRINT ~temp~ ~ACTION_DEFINE_ASSOCIATIVE_ARRAY temp_assoc BEGIN %arguments% END~
        INNER_ACTION BEGIN
        <<<<<<<< temp_file
        %temp%
        >>>>>>>>
          COPY + temp_file ~%workspace%/temp_file2~ EVALUATE_BUFFER
            REINCLUDE ~%workspace%/temp_file2~
        END
        LAUNCH_PATCH_FUNCTION patch_conditionally
             STR_VAR arguments=temp_assoc filename=EVALUATE_BUFFER ~%filename%~ file_prefix=EVALUATE_BUFFER ~%file_prefix%~
        END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               read or write the value of a field
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION get_field_value
        INT_VAR loc=0
                length=0
        RET value
BEGIN
   PATCH_MATCH length WITH
   1
   BEGIN
      READ_BYTE loc value
   END
   2
   BEGIN
      READ_SHORT loc value
   END
   4
   BEGIN
      READ_LONG loc value
   END
   DEFAULT
      LAUNCH_PATCH_FUNCTION patch_display_warning STR_VAR warning= EVALUATE_BUFFER ~Warning: trying to read %loc%, but %length% is unrecognised length~ END
   END
END

DEFINE_PATCH_FUNCTION set_field_value
        INT_VAR loc=0
                length=0
                value=0
BEGIN
   PATCH_MATCH length WITH
   1
   BEGIN
      WRITE_BYTE loc value
   END
   2
   BEGIN
      WRITE_SHORT loc value
   END
   4
   BEGIN
      WRITE_LONG loc value
   END
   DEFAULT
      LAUNCH_PATCH_FUNCTION patch_display_warning STR_VAR warning= EVALUATE_BUFFER ~Warning: trying to write %loc%, but %length% is unrecognised length~ END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               general template to add an entry type
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION add_entry
          STR_VAR arguments=""  // this is a patch
                  file_prefix=""
                  is_clone="no"
BEGIN
         SPRINT entry_type $EVALUATE_BUFFER ~%arguments%~(type)
         // get offsets for this entry type
         SET offset_loc=$EVALUATE_BUFFER ~%file_prefix%offset_loc~(~%entry_type%~)
         SET offset_length=$EVALUATE_BUFFER ~%file_prefix%offset_length~(~%entry_type%~)
         SET entrynum_loc=$EVALUATE_BUFFER ~%file_prefix%entrynum_loc~(~%entry_type%~)
         SET entrynum_length=$EVALUATE_BUFFER ~%file_prefix%entrynum_length~(~%entry_type%~)
         SET entry_length=$EVALUATE_BUFFER ~%file_prefix%entry_length~(~%entry_type%~)
         // get field values for these offsets
         LAUNCH_PATCH_FUNCTION get_field_value INT_VAR loc=offset_loc length=offset_length RET offset_start=value END
         LAUNCH_PATCH_FUNCTION get_field_value INT_VAR loc=entrynum_loc length=entrynum_length RET num_entries=value END
         // add another entry
         SET offset_base = offset_start + num_entries * entry_length
         INSERT_BYTES offset_base entry_length
         SET num_entries=num_entries+1
         LAUNCH_PATCH_FUNCTION set_field_value INT_VAR loc=entrynum_loc length=entrynum_length value=num_entries END
         // adjust offsets
         PHP_EACH EVALUATE_BUFFER ~%file_prefix%offset_loc~ AS this_type => this_offset_loc BEGIN
          PATCH_IF ~%this_type%~ STRING_COMPARE_CASE ~%entry_type%~ BEGIN
            SET this_offset_length =$EVALUATE_BUFFER ~%file_prefix%offset_length~(~%this_type%~)
            LAUNCH_PATCH_FUNCTION get_field_value INT_VAR loc=this_offset_loc length=this_offset_length RET this_offset_start=value END
            PATCH_IF (this_offset_start > offset_start) OR (this_offset_start=offset_start AND num_entries=1) BEGIN // second one catches cases where entry type was previously empty
               SET this_offset_start = this_offset_start + entry_length
               LAUNCH_PATCH_FUNCTION set_field_value INT_VAR loc=this_offset_loc length=this_offset_length value=this_offset_start END
            END
          END
         END
         // if this is an item or spell ability, sort out the offsets
         PATCH_IF ~%entry_type%~ STRING_EQUAL_CASE ~ability~ BEGIN
            LPF ~%file_prefix%_read_num_abils~ RET value=value END
            PATCH_IF value=1 BEGIN
                SET end_ind=0
            END ELSE BEGIN
                SET prev_base=offset_base - entry_length
                SET end_ind=(SHORT_AT (~prev_base~+0x1e))+(SHORT_AT (~prev_base~+0x20))
            END
            WRITE_SHORT offset_base+0x20 end_ind
            WRITE_SHORT offset_base+0x1e 0
         END
         // if this is a global effect, likewise
         PATCH_IF ~%entry_type%~ STRING_EQUAL_CASE ~effect_global~ BEGIN
            SPRINT entry_type ability
            LAUNCH_PATCH_MACRO get_offset_array
            PHP_EACH offset_array AS int=>offset BEGIN
                  WRITE_SHORT (offset+0x20) (SHORT_AT (offset+0x20) + 1)
            END
            SPRINT entry_type effect_global
         END

         LAUNCH_PATCH_FUNCTION apply_patches
                STR_VAR
                     edits=EVALUATE_BUFFER ~%arguments%~
                     file_prefix=EVALUATE_BUFFER ~%file_prefix%~
                     offset_base=EVALUATE_BUFFER ~%offset_base%~
                     offset_secondary=EVALUATE_BUFFER ~%offset_base%~ // note that this is for effect_global; you can't add effects this way
                     is_conditional="yes"
         END


END

DEFINE_PATCH_FUNCTION add_entry_inline
    STR_VAR arguments="" // this is a hash
            file_prefix=""
            filename=""
            is_clone="no"
BEGIN
        SPRINT ~temp~ ~ACTION_DEFINE_ASSOCIATIVE_ARRAY temp_assoc BEGIN %arguments% END~
        INNER_ACTION BEGIN
        <<<<<<<< temp_file
        %temp%
        >>>>>>>>
          COPY + temp_file ~%workspace%/temp_file2~ EVALUATE_BUFFER
            REINCLUDE ~%workspace%/temp_file2~
        END
        LAUNCH_PATCH_FUNCTION add_entry
             STR_VAR arguments=temp_assoc filename=EVALUATE_BUFFER ~%filename%~ file_prefix=EVALUATE_BUFFER ~%file_prefix%~ is_clone
        END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               general template to add an entry type as a clone of the first of its type, immediately following the first
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION add_entry_as_clone
          STR_VAR arguments=""  // this is a patch
                  file_prefix=""
BEGIN
         INNER_ACTION BEGIN FAIL ~The "add_entry_as_clone" function is obsolete~ END
         LPF add_entry STR_VAR arguments file_prefix is_clone="yes" END



END
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               general template to clone an entry based on matched conditions
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION clone_entry
    STR_VAR arguments="" // this is a hash
            file_prefix=""
            filename=""
BEGIN
    // find the entry type, match, and check
    SPRINT effect_patch ~~
    PHP_EACH ~%arguments%~ AS func=>arg BEGIN
       PATCH_MATCH ~%func%~ WITH 
         type BEGIN
            SPRINT entry_type ~%arg%~
         END
         match BEGIN
            SPRINT match ~%arg%~
         END
         match_parameter BEGIN
            SPRINT parameter ~%arg%~
         END
         check BEGIN
            SPRINT check ~%arg%~
         END
         effect_patch BEGIN
            SPRINT effect_patch ~%arg%~
         END
         DEFAULT END
    END
          PATCH_IF VARIABLE_IS_SET $autofunction(EVALUATE_BUFFER ~%file_prefix%_read_%match%~) BEGIN
             SPRINT match ~%file_prefix%_read_%match%~
          END ELSE
          PATCH_IF VARIABLE_IS_SET $autofunction(EVALUATE_BUFFER ~%file_prefix%_%match%~) BEGIN
             SPRINT match ~%file_prefix%_%match%~
          END
    PATCH_IF !VARIABLE_IS_SET ~%entry_type%~ BEGIN
       LPF patch_display_warning STR_VAR warning="Warning: no entry type found for clone_entry" END
    END
    PATCH_IF !VARIABLE_IS_SET ~%parameter%~ BEGIN
       SPRINT parameter NOT_SET
    END
    PATCH_IF (~%entry_type%~ STRING_EQUAL_CASE ~effect~ && (~%file_prefix%~ STRING_EQUAL_CASE SPL || ~%file_prefix%~ STRING_EQUAL_CASE ITM)) BEGIN 
         READ_LONG 0x6a effect_offset
         SPRINT entry_type ability
         LAUNCH_PATCH_MACRO get_offset_array
         SET number_effects_added=0
         PHP_EACH offset_array AS ab_num=>ab_off BEGIN
              SET number_effects_added_here=0
              READ_SHORT 0x1e+ab_off eff_num_here
              READ_SHORT 0x20+ab_off eff_ind_here
              SET eff_ind_here+=number_effects_added
              WRITE_SHORT 0x20+ab_off eff_ind_here
              FOR (i=eff_ind_here;i<eff_ind_here+eff_num_here;i+=1) BEGIN
                 SET offset_base=effect_offset+0x30*(i+number_effects_added_here)
                 LPF ~%match%~ INT_VAR offset_secondary=offset_base STR_VAR parameter offset_base filename file_prefix RET value=value END
                 PATCH_IF ~%value%~ STRING_EQUAL_CASE ~%check%~ BEGIN
                    SET number_effects_added_here +=1
                    READ_ASCII offset_base template (0x30)
                    INSERT_BYTES offset_base 0x30
                    WRITE_ASCIIE offset_base ~%template%~
                    LPF apply_patches INT_VAR offset_secondary=offset_base STR_VAR file_prefix is_conditional=yes filename arguments offset_base END
                 END
              END
              SET number_effects_added+=number_effects_added_here
              SET eff_num_here+=number_effects_added_here
              WRITE_SHORT 0x1e+ab_off eff_num_here
         END

    END ELSE BEGIN
         SET offset_loc=$EVALUATE_BUFFER ~%file_prefix%offset_loc~(~%entry_type%~)
         SET offset_length=$EVALUATE_BUFFER ~%file_prefix%offset_length~(~%entry_type%~)
         SET entrynum_loc=$EVALUATE_BUFFER ~%file_prefix%entrynum_loc~(~%entry_type%~)
         SET entrynum_length=$EVALUATE_BUFFER ~%file_prefix%entrynum_length~(~%entry_type%~)
         SET entry_length=$EVALUATE_BUFFER ~%file_prefix%entry_length~(~%entry_type%~)
         LPF get_field_value INT_VAR loc=offset_loc length=offset_length RET offset_start=value END
         LPF get_field_value INT_VAR loc=entrynum_loc length=entrynum_length RET num_entries=value END
         PATCH_IF ~%entry_type%~ STRING_EQUAL_CASE ability BEGIN
              READ_LONG 0x6a effect_offset
         END
         SET number_added=0
         SET number_effects_added=0
         FOR (i=0;i<num_entries;i+=1) BEGIN
            SET offset_base=offset_start + entry_length*(i + number_added)
            PATCH_IF ~%entry_type%~ STRING_EQUAL_CASE ability BEGIN
               READ_SHORT 0x1e+offset_base number_effects_here
               READ_SHORT 0x20+offset_base effect_ind_here
               SET effect_ind_here=effect_ind_here + number_effects_added
               WRITE_SHORT 0x20+offset_base effect_ind_here
            END
            LPF ~%match%~ INT_VAR offset_secondary=offset_base STR_VAR parameter offset_base filename file_prefix RET value=value END
            PATCH_IF ~%value%~ STRING_EQUAL_CASE ~%check%~ BEGIN
               READ_ASCII offset_base template (~entry_length~)
               INSERT_BYTES offset_base+entry_length entry_length
               WRITE_ASCIIE offset_base+entry_length ~%template%~ (~entry_length~)
               SET number_added=number_added + 1
               SET offset_for_patch=offset_base+entry_length
               LPF apply_patches INT_VAR offset_secondary=offset_for_patch STR_VAR is_conditional=yes file_prefix filename arguments offset_base=EVALUATE_BUFFER ~%offset_for_patch%~ END
               // abilities
               PATCH_IF ~%entry_type%~ STRING_EQUAL_CASE ability BEGIN
                  SET number_effects_added=number_effects_added+number_effects_here
                  WRITE_SHORT 0x20+offset_for_patch effect_ind_here+number_effects_here
                  READ_ASCII (effect_offset + effect_ind_here * 0x30 + number_added * entry_length) effect_template (0x30*number_effects_here)
                  INSERT_BYTES (effect_offset + (effect_ind_here + number_effects_added) * 0x30 + number_added * entry_length) (0x30* number_effects_here)
                  WRITE_ASCIIE (effect_offset + (effect_ind_here + number_effects_added) * 0x30 + number_added * entry_length) ~%effect_template%~
                  FOR (i=0;i<number_effects_here;i+=1) BEGIN
                     SET offset_for_effect_patch=effect_offset + (effect_ind_here + number_effects_added + i) * 0x30 + number_added * entry_length
                     PATCH_IF ~%effect_patch%~ STRING_COMPARE ~~ BEGIN
                        LPF apply_patches INT_VAR offset_secondary=offset_for_effect_patch STR_VAR file_prefix filename arguments=EVALUATE_BUFFER ~%effect_patch%~ offset_base=EVALUATE_BUFFER ~%offset_for_effect_patch%~ END
                     END
                  END
               END
            END
         END
         // adjust recorded number
         PATCH_IF number_added>0 BEGIN
            LPF set_field_value INT_VAR loc=entrynum_loc length=entrynum_length value=num_entries + number_added END
         END
         // adjust offsets
         PHP_EACH EVALUATE_BUFFER ~%file_prefix%offset_loc~ AS this_type => this_offset_loc BEGIN
          PATCH_IF ~%this_type%~ STRING_COMPARE_CASE ~%entry_type%~ BEGIN
            SET this_offset_length =$EVALUATE_BUFFER ~%file_prefix%offset_length~(~%this_type%~)
            LPF get_field_value INT_VAR loc=this_offset_loc length=this_offset_length RET this_offset_start=value END
            PATCH_IF (this_offset_start > offset_start) OR (this_offset_start=offset_start AND num_entries=0) BEGIN // second one catches cases where entry type was previously empty
               SET this_offset_start = this_offset_start + (entry_length * number_added)
               LPF set_field_value INT_VAR loc=this_offset_loc length=this_offset_length value=this_offset_start END
            END
          END
         END

    END
END

DEFINE_PATCH_FUNCTION clone_entry_inline
    STR_VAR arguments="" // this is a hash
            file_prefix=""
            filename=""
BEGIN
        SPRINT ~temp~ ~ACTION_DEFINE_ASSOCIATIVE_ARRAY temp_assoc BEGIN %arguments% END~
        INNER_ACTION BEGIN
        <<<<<<<< temp_file
        %temp%
        >>>>>>>>
          COPY + temp_file ~%workspace%/temp_file2~ EVALUATE_BUFFER
            REINCLUDE ~%workspace%/temp_file2~
        END
        LAUNCH_PATCH_FUNCTION clone_entry
             STR_VAR arguments=temp_assoc filename=EVALUATE_BUFFER ~%filename%~ file_prefix=EVALUATE_BUFFER ~%file_prefix%~
        END
END



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               general template to delete an entry type
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



DEFINE_PATCH_FUNCTION delete_entries    // this uses indirection: the entries are in an assoc_array
          STR_VAR arguments=""
                  file_prefix=""
BEGIN
          PATCH_IF VARIABLE_IS_SET $EVALUATE_BUFFER ~%arguments%~(match) BEGIN
             SPRINT match $EVALUATE_BUFFER ~%arguments%~(match)
          END ELSE BEGIN
             SPRINT match returns_true
          END
          PATCH_IF VARIABLE_IS_SET $EVALUATE_BUFFER ~%arguments%~(match_parameter) BEGIN
             SPRINT match_parameter $EVALUATE_BUFFER ~%arguments%~(match_parameter)
          END ELSE BEGIN
             SPRINT match_parameter NOT_SET
          END
          SPRINT type $EVALUATE_BUFFER ~%arguments%~(type)
          SET checktype=0
          PATCH_IF VARIABLE_IS_SET $EVALUATE_BUFFER ~%arguments%~(check) BEGIN
              SPRINT ~check~ $EVALUATE_BUFFER ~%arguments%~(check)
              SET checktype=1
          END ELSE
          PATCH_IF VARIABLE_IS_SET $EVALUATE_BUFFER ~%arguments%~(checkGT) BEGIN
              SPRINT ~check~ $EVALUATE_BUFFER ~%arguments%~(checkGT)
              SET checktype=2
          END ELSE
          PATCH_IF VARIABLE_IS_SET $EVALUATE_BUFFER ~%arguments%~(checkLT) BEGIN
              SPRINT ~check~ $EVALUATE_BUFFER ~%arguments%~(checkLT)
              SET checktype=3
          END ELSE BEGIN
             SPRINT check true
             SET checktype=1
          END
          PATCH_IF ~%type%~ STRING_EQUAL_CASE effect && (~%file_prefix%~ STRING_EQUAL_CASE ITM || ~%file_prefix%~ STRING_EQUAL_CASE SPL)BEGIN
               LPF patch_display_warning STR_VAR warning=~you have tried to use delete_entries_inline to remove extended effects. This doesn't work.~ END
          END
          LAUNCH_PATCH_FUNCTION delete_entries_on_condition
             STR_VAR match=EVALUATE_BUFFER ~%match%~
                     check=EVALUATE_BUFFER ~%check%~
                     checktype=EVALUATE_BUFFER ~%checktype%~
                     parameter=EVALUATE_BUFFER ~%match_parameter%~
                     entry_type=EVALUATE_BUFFER ~%type%~
                     file_prefix=EVALUATE_BUFFER ~%file_prefix%~
          END
END

DEFINE_PATCH_FUNCTION delete_entries_inline
        STR_VAR
               arguments=""
               file_prefix=""
BEGIN
        SPRINT ~temp~ ~ACTION_DEFINE_ASSOCIATIVE_ARRAY temp_assoc BEGIN %arguments% END~
        INNER_ACTION BEGIN
        <<<<<<<< temp_file
        %temp%
        >>>>>>>>
          COPY + temp_file ~%workspace%/temp_file2~ EVALUATE_BUFFER
          REINCLUDE ~%workspace%/temp_file2~
        END
        LAUNCH_PATCH_FUNCTION delete_entries
              STR_VAR arguments=temp_assoc file_prefix=EVALUATE_BUFFER ~%file_prefix%~
        END
END

DEFINE_PATCH_FUNCTION delete_entries_on_condition
         STR_VAR match=""
                 check=""
                 checktype=1
                 entry_type=""
                 file_prefix=""
                 parameter=""
BEGIN
         PATCH_IF ~%entry_type%~ STRING_EQUAL_CASE ability BEGIN
                SET step=1       // step 1 is to delete effects
         END ELSE BEGIN
                SET step=2       // step 2 is to delete entry
         END
         // get offsets for this entry type
         SET offset_loc=$EVALUATE_BUFFER ~%file_prefix%offset_loc~(~%entry_type%~)
         SET offset_length=$EVALUATE_BUFFER ~%file_prefix%offset_length~(~%entry_type%~)
         SET entrynum_loc=$EVALUATE_BUFFER ~%file_prefix%entrynum_loc~(~%entry_type%~)
         SET entrynum_length=$EVALUATE_BUFFER ~%file_prefix%entrynum_length~(~%entry_type%~)
         SET entry_length=$EVALUATE_BUFFER ~%file_prefix%entry_length~(~%entry_type%~)
         // get field values for these offsets
         LAUNCH_PATCH_FUNCTION get_field_value INT_VAR loc=offset_loc length=offset_length RET offset_start=value END
         LAUNCH_PATCH_FUNCTION get_field_value INT_VAR loc=entrynum_loc length=entrynum_length RET num_entries=value END
          PATCH_IF VARIABLE_IS_SET $autofunction(EVALUATE_BUFFER ~%file_prefix%_read_%match%~) BEGIN
             SPRINT match ~%file_prefix%_read_%match%~
          END ELSE
          PATCH_IF VARIABLE_IS_SET $autofunction(EVALUATE_BUFFER ~%file_prefix%_%match%~) BEGIN
             SPRINT match ~%file_prefix%_%match%~
          END

         // do the deletion
      WHILE step<3 BEGIN
         SET num_current=0
         SET num_deleted=0
         WHILE num_current<num_entries BEGIN
            SET offset_base=offset_start+entry_length*num_current
            LAUNCH_PATCH_FUNCTION ~%match%~ INT_VAR offset_base=offset_base STR_VAR parameter=EVALUATE_BUFFER ~%parameter%~ RET value=value END
            SET found_match=0
          PATCH_MATCH ~checktype~ WITH
          1 BEGIN
             PATCH_IF ~%value%~ STRING_EQUAL_CASE ~%check%~ BEGIN
                SET found_match=1
             END
          END
          2 BEGIN
             PATCH_IF ~value~ >= ~check~ BEGIN
                SET found_match=1
             END
          END
          3 BEGIN
             PATCH_IF ~value~ <= ~check~ BEGIN
                SET found_match=1
             END
          END
          DEFAULT
             LPF patch_display_warning STR_VAR warning="Warning: no check value in conditional delete" END
          END
          PATCH_IF found_match=1 BEGIN
              PATCH_IF step=1 BEGIN
                  GET_OFFSET_ARRAY2 eff_array offset_base ITM_V10_HEAD_EFFECTS
                  PHP_EACH eff_array AS int=>eff_off BEGIN
                         WRITE_SHORT eff_off  999
                  END
                  SET num_current = num_current + 1
              END ELSE BEGIN
               DELETE_BYTES offset_base entry_length
               SET num_entries = num_entries - 1
               SET num_deleted = num_deleted + 1
              END
           END ELSE BEGIN
               SET num_current = num_current + 1
           END
          END

          PATCH_IF step=1 BEGIN
            PATCH_IF ~%file_prefix%~ STRING_EQUAL_CASE itm BEGIN
               LPF DELETE_ITEM_EFFECT INT_VAR opcode_to_delete=999 END
            END ELSE BEGIN
               LPF DELETE_SPELL_EFFECT INT_VAR opcode_to_delete=999 END
            END

          END ELSE BEGIN
         // adjust the numbers
           LAUNCH_PATCH_FUNCTION set_field_value INT_VAR loc=entrynum_loc length=entrynum_length value=num_entries END
         // adjust the offsets
           PHP_EACH EVALUATE_BUFFER ~%file_prefix%offset_loc~ AS this_type => this_offset_loc BEGIN
            SET this_offset_length =$EVALUATE_BUFFER ~%file_prefix%offset_length~(~%this_type%~)
            LAUNCH_PATCH_FUNCTION get_field_value INT_VAR loc=this_offset_loc length=this_offset_length RET this_offset_start=value END
            PATCH_IF this_offset_start > offset_start BEGIN
               SET this_offset_start = this_offset_start - (num_deleted * entry_length)
               LAUNCH_PATCH_FUNCTION set_field_value INT_VAR loc=this_offset_loc length=this_offset_length value=this_offset_start END
            END
          END
         END
         SET step=step+1
      END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               general template to add an ability effect to a spell or item
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION add_effect
          STR_VAR arguments=""  // this is a patch
                  file_prefix=""
                  equipped="no"
BEGIN
   PATCH_IF debug_variable=2 BEGIN
        LPF patch_display_warning STR_VAR warning=EVALUATE_BUFFER ~add_effect input: %arguments%~ END
   END
     PATCH_IF ~%equipped%~ STRING_EQUAL_CASE "yes" BEGIN
       SPRINT runline ~LPF ADD_ITEM_EQEFFECT~
     END ELSE BEGIN
       PATCH_MATCH ~%file_prefix%~ WITH
       spl SPL BEGIN
         SPRINT runline ~LPF ADD_SPELL_EFFECT~
       END
       itm ITM BEGIN
         SPRINT runline ~LPF ADD_ITEM_EFFECT~
       END
       cre CRE BEGIN
             SPRINT runline ~LPF ADD_CRE_EFFECT~
       END
       DEFAULT
       PATCH_PRINT ~You haven't told add_effect the file prefix; assuming SPL~
         SPRINT runline ~LPF ADD_SPL_EFFECT~
       END
     END
     SET any=0
     SPRINT intvars ~~
     SPRINT strvars ~~
     PHP_EACH ~%arguments%~ AS input=>arg BEGIN
        PATCH_MATCH ~%input%~ WITH
                    opcode target timing parameter1 parameter2 power
                    resist_dispel duration probability1 probability2
                    dicenumber dicesize savingthrow savebonus header insert_point type
        BEGIN
           SPRINT intvars ~%intvars% %input%=%arg%~
        END
                     resource resource2 vvcresource effsource effvar
        BEGIN
           SPRINT strvars ~%strvars% %input%=%arg%~
        END
        DEFAULT END
     END
     PATCH_IF ~%intvars%~ STRING_COMPARE ~~ BEGIN
          SPRINT runline ~%runline% INT_VAR %intvars%~
     END
     PATCH_IF ~%strvars%~ STRING_COMPARE ~~ BEGIN
          SPRINT runline ~%runline% STR_VAR %strvars%~
     END
     SPRINT runline ~%runline% END~
     PATCH_IF debug_variable=2 BEGIN
        LPF patch_display_warning STR_VAR warning=EVALUATE_BUFFER ~including "%runline%"~ END
     END
     LPF patch_reinclude_this STR_VAR input=EVALUATE_BUFFER ~%runline%~ END
END

DEFINE_PATCH_FUNCTION add_effect_inline
          STR_VAR arguments=""
                  file_prefix=""
                  equipped="no"
BEGIN
        PATCH_CLEAR_ARRAY temp_assoc
        SPRINT list ~%arguments%~
        WHILE ~%list%~ STRING_COMPARE ~~ BEGIN
           LPF return_first_pair STR_VAR list RET list=list key=key value=value END
           SPRINT $temp_assoc(~%key%~) ~"%value%"~
        END
        LPF add_effect
           STR_VAR arguments=temp_assoc file_prefix=EVALUATE_BUFFER ~%file_prefix%~ equipped=EVALUATE_BUFFER ~%equipped%~
        END


END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              go through a set of entries, and run the PATCH_FUNCTION "function" with the  arguments "argument", "offset_base", and "file_prefix" on each one.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION walk_entries
         STR_VAR entry_type=""
                 file_prefix=""
                 function=""
                 arguments=""
                 filename=""
         RET value
BEGIN
         SET value=0
         LAUNCH_PATCH_MACRO get_offset_array
         PATCH_IF ~%entry_type%~ STRING_EQUAL_CASE ~effect_global~ BEGIN
            PHP_EACH offset_array AS int => offset_secondary BEGIN
                LAUNCH_PATCH_FUNCTION ~%function%~ INT_VAR offset_secondary=~offset_secondary~ STR_VAR arguments=EVALUATE_BUFFER ~%arguments%~ filename=EVALUATE_BUFFER ~%filename%~ file_prefix= EVALUATE_BUFFER ~%file_prefix%~  RET value_here=value END
                PATCH_IF ~%value_here%~ STRING_EQUAL_CASE 1 BEGIN
                   SET value=1
                END
            END
         END ELSE BEGIN
            PHP_EACH offset_array AS int => offset_base BEGIN
                LAUNCH_PATCH_FUNCTION ~%function%~ INT_VAR offset_base=~offset_base~ STR_VAR arguments=EVALUATE_BUFFER ~%arguments%~ filename=EVALUATE_BUFFER ~%filename%~ file_prefix= EVALUATE_BUFFER ~%file_prefix%~  RET value_here=value END
                PATCH_IF ~%value_here%~ STRING_EQUAL_CASE 1 BEGIN
                   SET value=1
                END
            END
         END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               walk the effect tree
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION walk_effect_tree
         INT_VAR
                ab_length=0
         STR_VAR entry_type=""
                 filename=""
                 file_prefix=""
                 function=""
                 arguments=""
BEGIN
   PATCH_MATCH ~%file_prefix%~ WITH itm ITM BEGIN
      SET ab_length=0x38
   END DEFAULT
      SET ab_length=0x28
   END
   GET_OFFSET_ARRAY ab_array 0x64 4 0x68 2 0 0 ~ab_length~
   PHP_EACH ab_array AS int => ab_off BEGIN
      GET_OFFSET_ARRAY2 eff_array ab_off ITM_V10_HEAD_EFFECTS
      PHP_EACH eff_array AS int => offset_secondary BEGIN
                LAUNCH_PATCH_FUNCTION ~%function%~ INT_VAR offset_base=~ab_off~ offset_secondary=offset_secondary STR_VAR arguments=EVALUATE_BUFFER ~%arguments%~ filename=EVALUATE_BUFFER ~%filename%~  file_prefix= EVALUATE_BUFFER ~%file_prefix%~ END
      END
   END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               walk the dialog transition tree
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION walk_transition_tree
         STR_VAR entry_type=""
                 filename=""
                 file_prefix=""
                 function=""
                 arguments=""
BEGIN
   GET_OFFSET_ARRAY state_array 0xc 4 0x8 4 0 0 0x10
   PHP_EACH state_array AS number_of_state => state_off BEGIN
      GET_OFFSET_ARRAY2 trans_array state_off 0x14 4 0x8 4 0x4 4 0x20
      PHP_EACH trans_array AS number_of_secondary => offset_secondary BEGIN
                LAUNCH_PATCH_FUNCTION ~%function%~ INT_VAR offset_base=~state_off~ offset_secondary= ~offset_secondary~ number_of_state=number_of_state number_of_secondary=number_of_secondary STR_VAR arguments=EVALUATE_BUFFER ~%arguments%~ filename=EVALUATE_BUFFER ~%filename%~ file_prefix= EVALUATE_BUFFER ~%file_prefix%~ END
      END
   END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               check the ini file
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION patch_check_ini
        STR_VAR ini=""
        RET value
BEGIN
        TO_LOWER ini
        PATCH_IF !VARIABLE_IS_SET $scs_ini_hash(EVALUATE_BUFFER ~%ini%~) BEGIN
           SET value=0
        END ELSE BEGIN
           SET value=$scs_ini_hash(EVALUATE_BUFFER ~%ini%~)
        END
END

DEFINE_ACTION_FUNCTION action_check_ini
       STR_VAR ini=""
       RET value
BEGIN
     OUTER_INNER_PATCH ~~ BEGIN
          LPF patch_check_ini STR_VAR ini=EVALUATE_BUFFER ~%ini%~ RET value=value END
     END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               get a local directory
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION get_directory
        RET directory
BEGIN
   SPRINT directory ~~
   PATCH_FOR_EACH loc IN component_loc local_loc BEGIN
     PATCH_IF EVALUATE_BUFFER ~%%loc%%~ STRING_COMPARE ~~ BEGIN
            SPRINT ~directory~ EVALUATE_BUFFER ~%directory%/%%loc%%~
      END
   END
END

DEFINE_ACTION_FUNCTION action_get_directory
        RET directory
BEGIN
   OUTER_INNER_PATCH ~~ BEGIN
      LPF get_directory RET directory=directory END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               install all the listed files
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION install
       STR_VAR file=""
               files=""
               location=""
               locbase=""
               inline="no"
BEGIN
       ACTION_IF ~%file%~ STRING_EQUAL_CASE ~~ BEGIN
          ACTION_IF ~%files%~ STRING_EQUAL_CASE ~~ BEGIN
              PRINT ~Warning: you've called an install with no argument~
          END ELSE BEGIN
              OUTER_SPRINT file ~%files%~
          END
       END
       PRINT ~Installing file(s) %file%~
       ACTION_IF ~%inline%~ STRING_EQUAL_CASE yes BEGIN
        OUTER_SPRINT location ~.../stratagems-inline~
       END ELSE BEGIN
        ACTION_IF ~%locbase%~ STRING_EQUAL ~~ BEGIN
          LAF action_get_directory RET directory=directory END
        END ELSE BEGIN
          OUTER_SPRINT directory ~\%locbase%~
        END
        ACTION_IF ~%location%~ STRING_COMPARE ~~ BEGIN
          OUTER_SPRINT ~location~ ~%scsroot%%directory%\%location%~
        END ELSE BEGIN
          OUTER_SPRINT ~location~ ~%scsroot%%directory%~
        END
       END
       OUTER_WHILE ~%file%~ STRING_COMPARE ~~ BEGIN
           LAF action_return_first_entry STR_VAR list=EVALUATE_BUFFER ~%file%~ RET entry=entry file=list END
           OUTER_PATCH ~%entry%~ BEGIN
              SET postfix_start = INDEX_BUFFER (~\.~) +1
              SET postfix_length = BUFFER_LENGTH - postfix_start
              READ_ASCII postfix_start postfix (~postfix_length~)
           END
           ACTION_IF (~%postfix%~ STRING_EQUAL_CASE ~baf~ || ~%postfix%~ STRING_EQUAL_CASE ~d~) BEGIN
              COMPILE ~%location%/%entry%~ EVALUATE_BUFFER
           END ELSE BEGIN
              COPY ~%location%/%entry%~ ~override~
           END

       END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Extend a script
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION extend
         STR_VAR file=""
                 files=""
                 script=""
                 top=""
                 bottom=""
                 location=""
                 locbase=""
                 tv="no"
                 inline="no"
                 ssl="no"
                 variables=""
BEGIN
       ACTION_IF ~%file%%files%%script%~ STRING_EQUAL_CASE ~~ BEGIN
              PRINT ~Warning: you've called an extend with no main file~
          END ELSE BEGIN
              OUTER_SPRINT file ~%file%%files%%script%~
       END
       ACTION_IF ~%inline%~ STRING_EQUAL_CASE yes BEGIN
        OUTER_SPRINT location ~.../stratagems-inline~
       END ELSE BEGIN
        ACTION_IF ~%locbase%~ STRING_EQUAL ~~ BEGIN
          LAF action_get_directory RET directory=directory END
        END ELSE BEGIN
          OUTER_SPRINT directory ~\%locbase%~
        END
        ACTION_IF ~%location%~ STRING_COMPARE ~~ BEGIN
          OUTER_SPRINT ~location~ ~%scsroot%%directory%\%location%~
        END ELSE BEGIN
          OUTER_SPRINT ~location~ ~%scsroot%%directory%~
        END
       END
       ACTION_IF ~%ssl%~ STRING_EQUAL_CASE yes BEGIN
         OUTER_SPRINT location ~..\%location%~
         ACTION_FOR_EACH script IN ~%top%~ ~%bottom%~ BEGIN
         ACTION_IF ~%script%~ STRING_COMPARE_CASE ~~ BEGIN
            LAF ssl_to_baf STR_VAR script location variables END
         END
        END
        OUTER_SPRINT location ~%workspace%\ssl_out~
       END
       OUTER_WHILE ~%file%~ STRING_COMPARE ~~ BEGIN
           LAF action_return_first_entry STR_VAR list=EVALUATE_BUFFER ~%file%~ RET entry=entry file=list END
           ACTION_IF tv STRING_EQUAL_CASE yes BEGIN
              OUTER_SPRINT entry ~%tutu_var%entry~
           END
           ACTION_IF ~%top%~ STRING_COMPARE_CASE ~~ BEGIN
              EXTEND_TOP ~%entry%.bcs~ ~%location%/%top%.baf~ EVALUATE_BUFFER
           END
           ACTION_IF ~%bottom%~ STRING_COMPARE_CASE ~~ BEGIN
              EXTEND_BOTTOM ~%entry%.bcs~ ~%location%/%bottom%.baf~ EVALUATE_BUFFER
           END
       END


END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Compile a script under a different name (syntax is oldname=>newname)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION compile_rename
STR_VAR file=""
        files=""
        location=""
BEGIN
       ACTION_IF ~%file%~ STRING_EQUAL_CASE ~~ BEGIN
          ACTION_IF ~%files%~ STRING_EQUAL_CASE ~~ BEGIN
              PRINT ~Warning: you've called a compile_rename with no main file~
          END ELSE BEGIN
              OUTER_SPRINT file ~%files%~
          END
       END
        LAF action_get_directory RET directory=directory END
        ACTION_IF ~%location%~ STRING_COMPARE ~~ BEGIN
          OUTER_SPRINT ~location~ ~%scsroot%%directory%\%location%~
        END ELSE BEGIN
          OUTER_SPRINT ~location~ ~%scsroot%%directory%~
        END
       OUTER_WHILE ~%file%~ STRING_COMPARE ~~ BEGIN
          LAF action_return_first_pair STR_VAR list=EVALUATE_BUFFER ~%file%~ RET oldscript=key newscript=value file=list END
          COPY ~%location%\%oldscript%.baf~ ~%workspace%\%newscript%.baf~
          COMPILE EVALUATE_BUFFER ~%workspace%\%newscript%.baf~
       END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Clone a script A=>B and then extend it with another script also called B
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION clone_extend
       STR_VAR arguments=""
               top="yes"
               location=""
               inline="no"
BEGIN
       ACTION_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
          LAF action_return_first_pair STR_VAR list=EVALUATE_BUFFER ~%arguments%~ RET source=key script=value arguments=list END
          COPY_EXISTING ~%source%.bcs~ ~override/%script%.bcs~
          ACTION_IF ~%top%~ STRING_EQUAL_CASE ~no~ BEGIN
               LAF extend STR_VAR files=EVALUATE_BUFFER ~%script%~ location inline bottom=EVALUATE_BUFFER ~%script%~ END
          END ELSE BEGIN
               LAF extend STR_VAR files=EVALUATE_BUFFER ~%script%~ location inline top=EVALUATE_BUFFER ~%script%~ END
          END
          LAF clone_extend STR_VAR arguments top location inline END
       END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               include all the listed files
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION include
       STR_VAR file=""
               files=""
               location=""
               locbase=""
BEGIN
       ACTION_IF ~%file%~ STRING_EQUAL_CASE ~~ BEGIN
          ACTION_IF ~%files%~ STRING_EQUAL_CASE ~~ BEGIN
              PRINT ~Warning: you've called an include with no argument~
          END ELSE BEGIN
              OUTER_SPRINT file ~%files%~
          END
       END
       PRINT ~Including file(s) %file%~
       ACTION_IF ~%locbase%~ STRING_EQUAL_CASE "" BEGIN
            LAF action_get_directory RET directory=directory END
       END ELSE BEGIN
            OUTER_SPRINT directory ~\%locbase%~
       END
       ACTION_IF ~%location%~ STRING_COMPARE ~~ BEGIN
          OUTER_SPRINT ~location~ ~%scsroot%%directory%\%location%~
       END ELSE BEGIN
          OUTER_SPRINT ~location~ ~%scsroot%%directory%~
       END
       OUTER_WHILE ~%file%~ STRING_COMPARE ~~ BEGIN
           LAF action_return_first_entry STR_VAR list=EVALUATE_BUFFER ~%file%~ RET entry=entry file=list END
           COPY ~%location%/%entry%~ ~%workspace%/%entry%~
              LPF define_make_patch END
              LPF define_push END
           REINCLUDE ~%workspace%/%entry%~
       END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               include all the listed files with a .tpa suffix, assume each contains a function with the same name as itself, and run that function
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION run
       STR_VAR file=""
               files=""
               location=""
               version=""
BEGIN
       ACTION_IF ~%file%~ STRING_EQUAL_CASE ~~ BEGIN
          ACTION_IF ~%files%~ STRING_EQUAL_CASE ~~ BEGIN
              PRINT ~Warning: you've called an include with no argument~
          END ELSE BEGIN
              OUTER_SPRINT file ~%files%~
          END
       END
       PRINT ~Including and running function(s) %file%~
       LAF action_get_directory RET directory=directory END
       ACTION_IF ~%location%~ STRING_COMPARE ~~ BEGIN
          OUTER_SPRINT ~location~ ~%scsroot%%directory%\%location%~
       END ELSE BEGIN
          OUTER_SPRINT ~location~ ~%scsroot%%directory%~
       END
       OUTER_WHILE ~%file%~ STRING_COMPARE ~~ BEGIN
           LAF action_return_first_entry STR_VAR list=EVALUATE_BUFFER ~%file%~ RET entry=entry file=list END
           COPY ~%location%/%entry%.tpa~ ~%workspace%/%entry%.tpa~
              LPF define_make_patch END
              LPF define_push END
           INCLUDE ~%workspace%/%entry%.tpa~
           LAF ~%entry%~ STR_VAR version=EVALUATE_BUFFER ~%version%~ END
       END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////     define the PATCH_MAKE_PATCH and MAKE_PATCH pseudocommands
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION define_make_patch BEGIN
   REPLACE_TEXTUALLY PATCH_MAKE_PATCH ~PATCH_CLEAR_ARRAY patch_data PATCH_DEFINE_ASSOCIATIVE_ARRAY patch_data BEGIN~
   REPLACE_TEXTUALLY MAKE_PATCH ~ACTION_CLEAR_ARRAY patch_data ACTION_DEFINE_ASSOCIATIVE_ARRAY patch_data BEGIN~
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////     define the PUSH pseudocommand
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION define_push BEGIN
   REPLACE_TEXTUALLY "PUSH ~\([^ ~]+\)~ " ~SPRINT "\1" "%\1% "^~
   REPLACE_TEXTUALLY "PUSH \([^ ~]+\)" ~SPRINT "\1" "%\1% "^~
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               make a unique name
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION make_unique_name
         INT_VAR try=0
         STR_VAR starts_with=""
                 file_prefix=""
         RET name try
BEGIN
   //    PATCH_PRINT ~looking to see if %starts_with%%try%.%file_prefix% exists in game~
         PATCH_IF FILE_EXISTS_IN_GAME ~%starts_with%%try%.%file_prefix%~ BEGIN
  //            PATCH_PRINT ~...it does~
              SET try=try+1
              LPF make_unique_name INT_VAR try STR_VAR starts_with=EVALUATE_BUFFER ~%starts_with%~ file_prefix=EVALUATE_BUFFER ~%file_prefix%~ RET try=try END
         END
   //      PATCH_PRINT ~...it doesn't~
         SPRINT ~name~ ~%starts_with%%try%~
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               always returns true
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


DEFINE_PATCH_FUNCTION returns_true RET value BEGIN  SPRINT value "true" END




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               make a textual substitution
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



DEFINE_PATCH_FUNCTION swap_text_core
     STR_VAR arguments=""
BEGIN
     PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
        LPF return_first_pair STR_VAR list=EVALUATE_BUFFER ~%arguments%~ RET arguments=list old=key new=value END
        PATCH_IF ~%new%~ STRING_EQUAL_CASE ~NULL~ BEGIN
           SPRINT ~new~ ~~
        END
        REPLACE_TEXTUALLY CASE_INSENSITIVE ~%old%~ ~%new%~
        LPF swap_text_core STR_VAR arguments=EVALUATE_BUFFER ~%arguments%~ END
     END
END

DEFINE_PATCH_FUNCTION swap_text_core2
     STR_VAR arguments=""
BEGIN
     PATCH_IF ~%arguments%~ STRING_COMPARE_CASE ~~ BEGIN
        LPF return_first_pair STR_VAR list=EVALUATE_BUFFER ~%arguments%~ RET arguments=list old=key new=value END
        PATCH_IF ~%new%~ STRING_EQUAL_CASE ~NULL~ BEGIN
           SPRINT ~new~ ~~
        END
        SET len1=STRING_LENGTH ~%old%~
        SET len2=STRING_LENGTH ~%new%~
        SET len = len1>len2?len1:len2
        REPLACE_TEXTUALLY CASE_INSENSITIVE ~%old%~ ~%new%~ (len)
        LPF swap_text_core2 STR_VAR arguments=EVALUATE_BUFFER ~%arguments%~ END
     END
END

DEFINE_ACTION_FUNCTION swap_text
    STR_VAR files=""
            swaps=""
            tv="no"
            postfix=""
            allow_missing="no"
BEGIN
    OUTER_WHILE ~%files%~ STRING_COMPARE_CASE ~~ BEGIN
      LAF action_return_first_entry STR_VAR list=EVALUATE_BUFFER ~%files%~ RET files=list entry=entry END

      ACTION_IF (~%tv%~ STRING_EQUAL_CASE yes) BEGIN
            OUTER_SPRINT ~entry~ ~%tutu_var%%entry%~
      END
      ACTION_IF (~%postfix%~ STRING_COMPARE_CASE ~~) BEGIN
            OUTER_SPRINT ~entry~ ~%entry%.%postfix%~
      END
      ACTION_IF (~%allow_missing%~ STRING_EQUAL_CASE no || FILE_EXISTS_IN_GAME ~%entry%~) BEGIN
         OUTER_PATCH ~%entry%~ BEGIN
              SET postfix_start = INDEX_BUFFER (~\.~) +1
              SET postfix_length = BUFFER_LENGTH - postfix_start
              READ_ASCII postfix_start pf (~postfix_length~)
         END
         ACTION_IF (~%pf%~ STRING_EQUAL_CASE ~bcs~ || ~%pf%~ STRING_EQUAL_CASE ~dlg~) BEGIN
              COPY_EXISTING ~%entry%~ ~override~
                   DECOMPILE_AND_PATCH BEGIN
                      LPF swap_text_core STR_VAR arguments = EVALUATE_BUFFER ~%swaps%~ END
                   END
              BUT_ONLY
         END ELSE BEGIN
              COPY_EXISTING ~%entry%~ ~override~
                      LPF swap_text_core2 STR_VAR arguments = EVALUATE_BUFFER ~%swaps%~ END
              BUT_ONLY
         END
      END
    END
END



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               combine two or more function checks (each must be argument-free)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION combine_checks 
   INT_VAR offset_base=0
           offset_secondary=0
   STR_VAR parameter=""
           filename=""
           file_prefix=""
   RET value
   BEGIN
        SET ~failed~=0
        LPF strip_quotes_from_string  STR_VAR string=EVALUATE_BUFFER ~%parameter%~ RET parameter=string END
        WHILE ~%parameter%~ STRING_COMPARE_CASE ~~ AND failed=0 BEGIN
           LPF return_first_pair STR_VAR list=EVALUATE_BUFFER ~%parameter%~ RET parameter=list function=key required_value=value END
           PATCH_IF ~%required_value%~ STRING_EQUAL_CASE ~NULL~ BEGIN
              SPRINT ~required_value~ ~~
           END
           LPF ~%function%~ INT_VAR offset_base=offset_base offset_secondary=offset_secondary STR_VAR arguments="" filename=EVALUATE_BUFFER ~%filename%~ file_prefix=EVALUATE_BUFFER ~%file_prefix%~ RET function_value=value END
           PATCH_IF ~%function_value%~ STRING_COMPARE_CASE ~%required_value%~ BEGIN
              SET ~failed~=1
           END
        END
        PATCH_IF ~failed~=1 BEGIN
           SET value=0
        END ELSE BEGIN
           SET value=1
        END
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               output  the name of the file
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION log_resource_name STR_VAR arguments="SFOlog" filename="" file_prefix="" BEGIN


   TO_LOWER file_prefix
   PATCH_MATCH ~%file_prefix%~ WITH itm BEGIN
      READ_STRREF 0xc name
      SPRINT output ~%filename% %name%~
   END
   cre spl BEGIN
      READ_STRREF 0x8 name
      SPRINT output ~%filename% %name%~
   END
   DEFAULT
      SPRINT output ~%filename%~
   END

   INNER_ACTION BEGIN
   <<<<<<<< log.txt
   >>>>>>>>


      ACTION_IF !FILE_EXISTS ~%workspace%/%arguments%.txt~ BEGIN
         COPY log.txt ~%workspace%/%arguments%.txt~
      END
      APPEND_OUTER ~%workspace%/%arguments%.txt~ ~%output%~
   END

END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///  generic logger
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION log_this
        STR_VAR file=""
                input=""
                repeat="yes"
BEGIN
    ACTION_IF !~%file%~ STRING_EQUAL_CASE ~auto_function_list.txt~ BEGIN  // in case we left any in place!
        ACTION_IF debug_variable>0 BEGIN
           PRINT ~trying to append %input% to %workspace%/%file%~
        END
        ACTION_IF !FILE_EXISTS ~%workspace%/%file%~ BEGIN
           COPY ~.../stratagems-inline/blank~ ~%workspace%/%file%~
        END
        ACTION_IF (~%repeat%~ STRING_COMPARE_CASE ~no~ || !(FILE_CONTAINS_EVALUATED (~%workspace%/%file%~ ~%input%~))) BEGIN
           APPEND_OUTER ~%workspace%/%file%~ ~%input%~
        END
    END
END

DEFINE_PATCH_FUNCTION patch_log_this
        STR_VAR file=""
                input=""
                repeat="yes"
BEGIN
        INNER_ACTION BEGIN
          LAF log_this STR_VAR file input repeat END
        END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///  generic opcode reader
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION read_opcode
               INT_VAR offset_secondary=0
               RET value
BEGIN
       READ_ASCII 0x0 file_prefix (3)
       TO_UPPER file_prefix
       LPF ~%file_prefix%_read_opcode~ INT_VAR offset_secondary RET value=value END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///  read in a row of a table into a string of variables
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION read_in_2da_row
               INT_VAR row=0
               STR_VAR list=""
               RET value
BEGIN
       READ_ASCII 0x0 file_prefix (3)
       TO_UPPER file_prefix
       LPF ~%file_prefix%_read_opcode~ INT_VAR offset_secondary RET value=value END
END





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Make a label
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION make_label
    STR_VAR label=""
BEGIN
   LAF get_label_loc RET location=location END
   COPY_EXISTING ~misc01.itm~ ~%location%/%label%.mrk~
   LPF patch_log_this STR_VAR file=SSL_warnings.txt input=EVALUATE_BUFFER ~Component with label:%label%~ END
END

DEFINE_ACTION_FUNCTION get_label_loc
RET location
BEGIN
   LAF action_check_ini STR_VAR ini=put_labels_in_workspace RET loc=value END
   ACTION_IF loc BEGIN
       OUTER_SPRINT location ~%workspace%~
   END ELSE BEGIN
       OUTER_SPRINT location ~override~
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Check a label
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION check_label
    STR_VAR label=""
    RET value
BEGIN
   LAF get_label_loc RET location=location END
   ACTION_IF FILE_EXISTS ~%location%/%label%.mrk~ BEGIN
      OUTER_SET value=1
   END ELSE BEGIN
      OUTER_SET value=0
   END
END

DEFINE_PATCH_FUNCTION check_label
   STR_VAR label=""
   RET value
BEGIN
   INNER_ACTION BEGIN
      LAF check_label STR_VAR label RET value=value END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Say something at an offset
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION say_this_here
      INT_VAR offset=0
              say=0
BEGIN
   SPRINT input ~SAY %offset% %atsymbol%%say%~
   LPF patch_reinclude_this STR_VAR input END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Take a LONG and reverse the first and last SHORT
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION reverse_long
      INT_VAR input=0
      RET output
BEGIN
   INNER_PATCH ~~ BEGIN
      INSERT_BYTES 0x0 0x4
      WRITE_LONG 0x0 input
      READ_SHORT 0x0 first 
      READ_SHORT 0x2 second
      WRITE_SHORT 0x0 second
      WRITE_SHORT 0x2 first
      READ_LONG 0x0 output
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               Return the offset of a given entry
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_PATCH_FUNCTION return_offset
        INT_VAR offset_num=0
        STR_VAR file_prefix=""
                entry_type=""
        RET value
BEGIN
   SET offset_loc=$EVALUATE_BUFFER ~%file_prefix%offset_loc~(~%entry_type%~)
   SET offset_length=$EVALUATE_BUFFER ~%file_prefix%offset_length~(~%entry_type%~) 
   PATCH_MATCH offset_length WITH
   2 BEGIN
      READ_SHORT offset_loc offset_base
   END
   4 BEGIN
      READ_LONG offset_loc offset_base
   END
   DEFAULT
      LPF patch_display_warning STR_VAR warning="warning: unknown length of offset" END
   END
   SET entry_length=$EVALUATE_BUFFER ~%file_prefix%entrynum_length~(~%entry_type%~)
   SET value=offset_base + offset_num * entry_length
END


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////               hack! - to work around the fact that the PATCH_MATCH in apply_patches doesn't always seem to notice check or type
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


ACTION_FOR_EACH prefix IN ARE CRE SPL DLG ITM STO BEGIN
   ACTION_FOR_EACH main IN check checkGT checkLT type BEGIN
      OUTER_SPRINT input ~DEFINE_PATCH_FUNCTION %prefix%_%main% BEGIN END~
      LAF action_reinclude_this STR_VAR input END
   END
END



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              load a file (which should be a 1-column array) and turn col 1 into a white-space-separated list
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION read_in_list
     STR_VAR file=""
     RET list
BEGIN
     COPY ~%file%~ ~%workspace%~
           SPRINT list ""
           COUNT_2DA_ROWS 0 rowcount
           FOR (i=0;i<rowcount;i+=1) BEGIN
              READ_2DA_ENTRY i 0 0 entry
              SPRINT list ~%list% %entry%~
           END
     BUT_ONLY
END

DEFINE_PATCH_FUNCTION read_in_list
      STR_VAR file=""
      RET list
BEGIN
   INNER_ACTION BEGIN
      LAF read_in_list STR_VAR file RET list=list END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              load a file (which should be a 2-column array) and turn col 1-2 into an associative array list ("key1=>value1 key2=>value2" etc)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION read_in_assoc_array
     STR_VAR file=""
     RET list
BEGIN
     COPY ~%file%~ ~%workspace%~
           SPRINT list ""
           COUNT_2DA_ROWS 1 rowcount
           FOR (i=0;i<rowcount;i+=1) BEGIN
              READ_2DA_ENTRY i 0 0 key
              READ_2DA_ENTRY i 1 0 value
              SPRINT list ~%list% %key%=>%value%~
           END
     BUT_ONLY
END

DEFINE_PATCH_FUNCTION read_in_assoc_array
      STR_VAR file=""
      RET list
BEGIN
   INNER_ACTION BEGIN
      LAF read_in_assoc_array STR_VAR file RET list=list END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              count the files of a given type
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION count_files
      STR_VAR file_prefix=""
              tv="no"
      RET value
BEGIN
      ACTION_IF ~%tv%~ STRING_EQUAL_CASE yes BEGIN
         OUTER_SPRINT base ~%tutu_var%~
      END ELSE BEGIN
         OUTER_SPRINT base ~~
      END
      OUTER_SET value=0
      COPY_EXISTING_REGEXP GLOB ~%base%.*\.%file_prefix%~ ~override~
            SET value+=1
      BUT_ONLY
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              count a list
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION count_list
    STR_VAR list=""
    RET value
BEGIN
   OUTER_SET value=0
   OUTER_WHILE list STRING_COMPARE ~~ BEGIN
      LAF action_return_first_entry STR_VAR list RET entry=entry list=list END
      OUTER_SET value+=1
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              clone a list of scripts
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



DEFINE_ACTION_FUNCTION clone_script
    STR_VAR script=""
BEGIN
   ACTION_IF ~%script%~ STRING_COMPARE_CASE ~~ BEGIN
      LAF action_return_first_pair STR_VAR list=EVALUATE_BUFFER ~%script%~ RET script=list old=key new=value END
      COPY_EXISTING ~%old%.bcs~ ~override/%new%.bcs~
      LAF clone_script STR_VAR script END
   END
END

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////              get an RGB LONG
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DEFINE_ACTION_FUNCTION color
    INT_VAR red=0
            green=0
            blue=0
    RET color
BEGIN

   OUTER_INNER_PATCH ~~ BEGIN
      INSERT_BYTES 0x0 4
      WRITE_BYTE 0x1 red
      WRITE_BYTE 0x2 green
      WRITE_BYTE 0x3 blue
      READ_LONG 0x0 color
   END


END




